<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Caregiver Report</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <style>
    :root{ --card:#fff; --border:#e9e9e9; --muted:#666; }
    html,body{height:auto;min-height:100%;overflow-y:auto}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#f7f7f8;margin:0}
    main.page{max-width:1200px;margin:0 auto;padding:26px 20px 20px;position:relative}
    main.page > h1{padding-right:260px}

    h1,h2{margin:10px 0;text-align:center}
    h3{margin:.25rem 0 .5rem;text-align:center}

    .panel{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:14px;margin:14px 0}
    .toolbar{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:flex-start;margin:.5rem 0 .75rem}
    .toolbar-actions{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-left:auto}
    select,button{padding:10px 14px;border:1px solid var(--border);border-radius:12px;background:#fff;font-size:15px;font-weight:600}
    .toolbar input[type="date"],
    .toolbar select,
    .toolbar button{min-height:46px}
    .toolbar label{display:flex;flex-direction:column;gap:4px;font-size:14px;font-weight:600}
    button{cursor:pointer;transition:background .15s ease}
    button:hover{background:#f5f5f5}
    button:active{background:#f0f0f0}
    button:focus-visible{outline:2px solid #2563eb;outline-offset:2px}
    #cgCaregiver{min-width:230px;font-weight:700}
    #cgQuickLookToggle,
    #cgPdf,
    #cgCsv{font-size:15px}
    #cgNotesToggle{font-size:14px}

    .cg-filter-banner{display:flex;justify-content:space-between;align-items:center;gap:10px;padding:10px 12px;margin:6px 0 12px;border:1px solid #fde68a;border-radius:12px;background:#fff7ed;font-weight:600}
    .cg-filter-banner button{border-color:#f59e0b}
    .cg-advanced-filters{border:1px solid #e5e7eb;border-radius:12px;padding:8px 12px;background:#fff}
    .cg-advanced-filters summary{cursor:pointer;font-weight:700}
    .cg-filter-grid{display:flex;flex-wrap:wrap;gap:12px;align-items:flex-end;margin-top:10px}
    .cg-filter-grid button{min-height:42px}
    .cg-clear-filters{font-size:13px}

    table{width:100%;border-collapse:collapse}
    th,td{border:1px solid #ddd;padding:8px;vertical-align:middle}
    thead th{background:#fafafa;position:sticky;top:0}
    #cgTable tbody tr{height:64px}
    #cgTable td{line-height:1.2}
    .cg-notes-cell{max-width:320px}
    .cg-note-preview{display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;min-height:32px;white-space:pre-wrap}
    .cg-note-btn{margin-top:4px;font-size:12px;border:1px solid #d4d4d8;border-radius:8px;padding:4px 8px;background:#fff;cursor:pointer;font-weight:600}
    .cg-note-btn:hover{background:#f1f5f9}
    .cg-note-full{display:none;white-space:pre-wrap}
    body.cg-notes-expanded #cgTable tbody tr{height:auto}
    body.cg-notes-expanded .cg-note-preview,
    body.cg-notes-expanded .cg-note-btn{display:none}
    body.cg-notes-expanded .cg-note-full{display:block}
    body.cg-export-notes .cg-note-preview,
    body.cg-export-notes .cg-note-btn{display:none}
    body.cg-export-notes .cg-note-full{display:block}
    body.cg-export-notes #cgTable tbody tr{height:auto}
    .cg-edit-btn{padding:6px 10px;font-size:13px;border-radius:8px;border:1px solid #c4c4c8;background:#f8fafc}
    .cg-edit-btn:hover{background:#eef2ff}

    .muted{color:var(--muted);font-size:13px;text-align:center;margin:.35rem 0}

    .kpis{display:grid;grid-template-columns:repeat(auto-fit,minmax(170px,1fr));gap:12px;margin:14px 0}
    .kpi{background:var(--card);border:1px solid var(--border);border-radius:12px;text-align:center;padding:12px;box-shadow:0 6px 18px rgba(148,163,184,.12)}
    .kpi .label{font-size:12px;color:var(--muted)}
    .kpi .value{margin-top:6px;font-size:20px;font-weight:700}

    .mood-summary-card{display:none;border:1px solid var(--border);border-radius:12px;padding:10px;background:#fff;box-shadow:0 6px 18px rgba(148,163,184,.12);margin-top:10px}
    .mood-summary-title{font-weight:700;margin-bottom:8px}
    .mood-summary-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;font-size:13px}
    .mood-summary-grid > div{border:1px solid #e5e7eb;border-radius:10px;padding:8px;background:#fff;box-shadow:0 4px 12px rgba(148,163,184,.12)}
    .mood-summary-grid .label{color:var(--muted);display:block;font-size:12px}
    .mood-summary-grid .value{font-weight:700}

    .pdf-only{display:none}
    .cg-summary-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin:8px 0 14px}
    .cg-summary-card{border:1px solid #e5e7eb;border-radius:12px;padding:10px;background:#fff;box-shadow:0 6px 18px rgba(148,163,184,.12);font-size:12px;line-height:1.35}
    .cg-summary-card h4{margin:0 0 6px;font-size:13px}
    .cg-summary-row{display:flex;justify-content:space-between;gap:8px;border-bottom:1px dashed #e5e7eb;padding:4px 0}
    .cg-summary-row:last-child{border-bottom:0}
    .cg-summary-row .label{color:var(--muted)}

    .chart{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px;margin:16px auto;max-width:940px}
    .chart.small{max-width:700px}
    canvas{display:block;max-width:100% !important;height:auto !important}
    .movement-panel{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px;margin:12px 0}
    .movement-panel h3{margin:0 0 6px;text-align:left}
    .movement-sub{margin:0 0 10px;font-size:12px;color:var(--muted)}
    .movement-summary{display:grid;gap:10px;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));margin-bottom:12px}
    .movement-summary .row{display:flex;justify-content:space-between;gap:8px;font-size:13px;border-bottom:1px solid #f1f5f9;padding:6px 0}
    .movement-summary .row:last-child{border-bottom:0}
    .movement-summary .label{color:#4b5563}
    .movement-summary .value{font-weight:700;color:#111}
    .movement-grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));}
    .movement-card{
      background:#fff;border:1px solid #e5e7eb;border-radius:16px;
      padding:12px;min-height:180px;
      box-shadow:0 1px 0 rgba(0,0,0,.02);
    }
    .movement-card h4{margin:0 0 8px;font-size:14px;text-align:left}
    .movement-card canvas{height:140px !important}

    /* ===== Health Calendar (scoped) ===== */
    .hc-wrap{max-width:1200px;margin:16px auto}
    .hc-card{background:#fff;border:1px solid #e9e9e9;border-radius:16px;box-shadow:0 12px 30px rgba(0,0,0,.04)}
    .hc-head{display:flex;justify-content:space-between;align-items:center;padding:14px 16px;border-bottom:1px solid #e9e9e9}
    .hc-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .hc-title{font-weight:900;font-size:18px}
    .hc-btn{appearance:none;border:1px solid #e9e9e9;background:#fff;padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:700}
    .hc-kvs{display:none}
    .hc-kv{background:#fafafa;border:1px solid #e9e9e9;border-radius:12px;padding:8px 10px;font-weight:700}
    .hc-legend{display:flex;gap:14px;align-items:center;flex-wrap:wrap;padding:10px 16px;border-top:1px solid #e9e9e9}
    .hc-emo{font-size:22px}
    .hc-grid{display:grid;grid-template-columns:repeat(7,minmax(110px,1fr));border-top:1px solid #e9e9e9}
    .hc-dow{padding:10px 8px;text-align:center;font-weight:800;color:#6b7280;background:#fafafa;border-bottom:1px solid #e9e9e9}
    .hc-cell{min-height:120px;padding:8px;border-bottom:1px solid #e9e9e9;border-right:1px solid #e9e9e9;position:relative;background:#fff;cursor:pointer}
    .hc-cell:nth-child(7n){border-right:0}
    .hc-date{font-weight:900;font-size:13px;color:#111}
    .hc-icons{display:flex;gap:6px;margin-top:6px;font-size:24px;line-height:1;flex-wrap:wrap}
    .hc-empty{color:#6b7280;position:absolute;left:8px;bottom:8px;font-size:12px}
    .hc-events{margin-top:6px;display:flex;flex-direction:column;gap:4px}
    .hc-event-pill{display:inline-flex;align-items:center;gap:6px;padding:3px 6px;border-radius:8px;background:#eef2ff;font-size:11px;font-weight:600;color:#1d4ed8;max-width:100%}
    .hc-event-pill span{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .hc-legend label{display:flex;align-items:center;gap:4px;font-weight:600}
    .hc-legend select{padding:6px 8px;border-radius:8px;border:1px solid #e5e7eb;background:#fff}

    /* ===== Quick Look summary ===== */
    .is-hidden{display:none !important}
    .quick-look{border:1px dashed #d4d4d8;border-radius:12px;padding:12px;margin:10px 0 16px;background:#fffef9;box-shadow:0 10px 18px rgba(148,163,184,.15)}
    .quick-look-head{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:10px}
    .quick-look-label{font-size:15px;font-weight:700}
    .quick-look-subtitle{font-size:12px;color:var(--muted)}
    .quick-look-content{display:grid;grid-template-columns:repeat(auto-fit,minmax(230px,1fr));gap:12px}
    .quick-look-card{border:1px solid #e5e7eb;border-radius:14px;padding:12px;background:#fff;box-shadow:0 8px 18px rgba(15,23,42,.07);display:flex;flex-direction:column;gap:8px}
    .quick-look-header{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .quick-look-date{font-size:16px;font-weight:700}
    .quick-look-print{border:1px solid #d4d4d8;border-radius:10px;padding:8px 12px;background:#f8fafc;font-size:13px;font-weight:700;cursor:pointer}
    .quick-look-print:hover{background:#eef2ff}
    .quick-look-count{font-size:13px;color:#4b5563;font-weight:600;margin-top:-4px}
    .focus-board{background:#fff9f3;border:1px dashed #fcd34d;border-radius:14px;padding:14px;margin:14px 0 26px}
    #cg-panel .toolbar{margin-top:16px}
    /* Post-it style for Weekly Focus */
    #reportFocusPanel{
      max-width:220px;
      margin:0;
      background:#fff7b5;
      border:1px solid #f4c84a;
      box-shadow:0 18px 30px rgba(0,0,0,.12);
      transform:rotate(-1.2deg);
      position:absolute;
      top:-6px;
      right:6px;
      z-index:3;
    }
    #reportFocusPanel h2{font-size:16px;margin-bottom:4px}
    #reportFocusPanel .muted{font-size:11px}
    #reportFocusPanel .focus-goal-list{display:none}
    #reportFocusPanel .focus-goal-list li{display:none}
    #reportFocusPanel #plannerChartSection{margin-top:6px}
    #reportFocusPanel #plannerChartWrap{padding:5px}
    #reportFocusPanel #focusGoalChart{display:none !important}
    #reportFocusPanel #plannerChartSection h3{display:none}
    #reportFocusPanel #focusPlannerStats{display:none !important}
    /* Shorten card height */
    #reportFocusPanel .focus-goal-list li{display:none}
    #reportFocusPanel .focus-goal-list li:first-child{display:block}
    #reportFocusPanel #plannerChartSection{display:block}
    #reportFocusPanel #focusGoalChart{display:none}
    @media (max-width: 720px){
      #reportFocusPanel{
        max-width:100%;
        transform:none;
        position:static;
        margin:8px 0 12px;
      }
      main.page > h1{padding-right:0}
    }
    .top-actions{margin:6px 0 8px !important}
    .top-actions button{padding:5px 8px;font-size:11px}
    .focus-board h2{margin-top:0}
    .focus-board .muted{margin-bottom:10px}
    .focus-goal-list{list-style:none;padding:0;margin:0;display:grid;gap:10px}
    .focus-goal-list li{background:#fff;border:1px solid #fcd34d;border-radius:12px;padding:10px;font-size:14px;line-height:1.4}
    .focus-goal-list li strong{display:block;margin-bottom:4px}
    #reportFocusPanel #focusGoalChart{
      display:block;
      width:100% !important;
      max-width:360px;
      height:260px !important;
      max-height:260px;
      margin:12px auto 0;
    }
    .planner-chart-panel{max-width:520px;margin:8px 0 14px}
    .planner-chart-panel.is-hidden{display:none}
    .planner-chart-wrap{margin:0;border:1px solid rgba(250,204,21,.55);border-radius:12px;padding:6px 8px;background:#fffdf4;box-shadow:inset 0 1px 0 rgba(253,224,71,.25)}
    .planner-chart-wrap.is-hidden{display:none}
    .planner-chart-wrap.compact{max-width:520px;margin:0}
    .wyr-graphic{margin-top:8px}
    .wyr-graphic svg{width:100%;height:auto;display:block}
    .wyr-graphic.is-hidden{display:none}
    .practice-row{display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:6px;align-items:center;max-height:none}
    .practice-cell{display:flex;flex-direction:column;align-items:center;gap:4px;font-size:11px;color:#6b7280}
    .practice-cell .label{display:none}
    .practice-dot{width:22px;height:22px;border-radius:999px;display:grid;place-items:center;font-weight:800;font-size:10px}
    .practice-dot.on{background:#fcd34d;color:#111;border:2px solid #f59e0b}
    .practice-dot.off{background:#f8fafc;color:#cbd5f5;border:1px dashed #e2e8f0}
    .practice-dot.off::after{content:"â€“";font-weight:700}
    .focus-pdf-summary{border:1px solid #e5e7eb;border-radius:12px;padding:10px;margin:8px 0;background:#fff;box-shadow:0 6px 18px rgba(148,163,184,.12)}
    .focus-pdf-title{font-weight:700;margin-bottom:6px}
    .focus-pdf-body{font-size:13px;line-height:1.4;color:#111}
    .focus-pdf-stats{font-size:12px;color:#4b5563;margin-top:6px}
    .hc-kv span{white-space:nowrap}
    .quick-look-metrics{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;margin:0 0 8px}
    .quick-look-metric{border:1px solid #e2e8f0;border-radius:8px;padding:6px;background:#f8fafc;display:flex;flex-direction:column;gap:2px}
    .quick-look-metric .metric-label{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.04em}
    .quick-look-metric .metric-value{font-size:15px;font-weight:600}
    .quick-look-caregivers{font-size:12px;color:var(--muted);margin:4px 0 0}
    .quick-look-note{font-size:13px;color:#374151;margin:6px 0 0}
    .quick-look-notes-btn{margin-top:4px;font-size:12px;border:1px solid #d4d4d8;border-radius:8px;padding:4px 8px;background:#fff;cursor:pointer;font-weight:600}
    .quick-look-notes-btn:hover{background:#f1f5f9}
    .quick-look-notes{margin-top:6px;border-top:1px dashed #e5e7eb;padding-top:6px}
    .quick-look-notes-list{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:6px;font-size:13px}
    .quick-look-note-row{border:1px solid #e5e7eb;border-radius:8px;padding:6px;background:#fafafa}
    .quick-look-note-meta{font-size:12px;color:#6b7280;margin-bottom:4px;font-weight:600}
    .quick-look-note-text{white-space:pre-wrap}
    .quick-look-print-sheet{max-width:640px;margin:0 auto;padding:18px;border:1px solid #d4d4d8;border-radius:16px;background:#fff;box-shadow:0 25px 40px rgba(15,23,42,.15);font-size:12px;line-height:1.35}
    .quick-look-print-sheet.is-hidden{display:none}
    .quick-look-print-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
    .quick-look-print-head h2{margin:0;font-size:18px}
    .quick-look-print-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:8px;margin-bottom:10px}
    .quick-look-print-notes{border-top:1px solid #e5e7eb;padding-top:8px}
    .quick-look-print-note{border:1px solid #e5e7eb;border-radius:8px;padding:6px;margin-bottom:6px;font-size:11px;line-height:1.4}
    .quick-look-print-note-text{white-space:pre-wrap}
    .quick-look-print-note:last-child{margin-bottom:0}

    /* ===== Calendar insights ===== */
    .calendar-insights{max-width:1200px;margin:10px auto 20px;display:grid;grid-template-columns:minmax(240px,320px) 1fr;gap:16px;align-items:start}
    .calendar-card{background:#fff;border:1px solid #e5e7eb;border-radius:18px;box-shadow:0 12px 30px rgba(15,23,42,.06);padding:16px}
    .calendar-card h3{margin:0 0 8px;font-size:20px;text-align:left}
    .calendar-sub{margin:0 0 12px;color:#6b7280;font-weight:600}
    .calendar-quick-list{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:10px}
    .calendar-quick-item{display:flex;align-items:center;justify-content:space-between;background:#f8fafc;border:1px solid #e2e8f0;border-radius:12px;padding:10px 12px;font-weight:700;color:#475569}
    .calendar-quick-label{display:flex;align-items:center;gap:8px}
    .calendar-quick-emoji{font-size:18px}
    .calendar-quick-count{font-size:18px;color:#0f172a}
    .monthly-shifts-list{display:flex;flex-direction:column;gap:12px}
    .monthly-shift-card{border:1px solid #e2e8f0;border-radius:14px;padding:12px;background:#fff;box-shadow:0 8px 20px rgba(15,23,42,.06)}
    .monthly-shift-title{margin:0 0 8px;font-size:16px;font-weight:700;color:#0f172a}
    .monthly-shift-row{display:flex;align-items:center;justify-content:space-between;padding:4px 0;font-weight:600;color:#64748b}
    .monthly-shift-row .delta{font-weight:800}
    .delta.pos{color:#16a34a}
    .delta.neg{color:#dc2626}
    @media (max-width:640px){
      .quick-look-content{grid-template-columns:1fr}
    }
    @media (max-width:900px){
      .calendar-insights{grid-template-columns:1fr}
    }
    body.quick-look-mode .top-actions{display:none}
    body.quick-look-mode main.page > :not([data-print-section="Caregiver Overview"]){display:none}
    body.quick-look-mode #cg-panel .cg-hide-when-quick-look{display:none}
    body.quick-look-mode #cgQuickLook{display:block}
    body.quick-look-mode #cgQuickLook.is-hidden{display:block}

    .hc-editor-overlay{position:fixed;inset:0;background:rgba(15,23,42,.45);display:flex;align-items:center;justify-content:center;z-index:10000}
    .hc-editor-overlay.is-hidden{display:none}
    .hc-editor{background:#fff;border-radius:18px;padding:20px;width:min(420px,90vw);box-shadow:0 32px 60px rgba(15,23,42,.35);display:flex;flex-direction:column;gap:12px}
    .hc-editor h3{margin:0;font-size:18px}
    .hc-editor fieldset{border:0;padding:0;margin:0;display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
    .hc-editor label{display:flex;align-items:center;gap:6px;font-weight:600;font-size:13px}
    .hc-editor textarea,
    .hc-editor input[type="number"],
    .hc-editor select{width:100%;padding:8px;border-radius:8px;border:1px solid #d4d4d8;font-size:13px;font-family:inherit}
    .hc-editor textarea{min-height:70px;resize:vertical}
    .hc-editor .actions{display:flex;justify-content:flex-end;gap:10px;margin-top:4px}
    .hc-editor .actions button{padding:8px 14px;border-radius:8px;border:1px solid #d4d4d8;background:#fff;cursor:pointer;font-weight:600}
    .hc-editor .actions button.primary{background:#111827;color:#fff;border-color:#111827}

    .cg-edit-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(15,23,42,.55);z-index:10000;padding:16px}
    .cg-edit-overlay.is-hidden{display:none!important}
    .cg-edit-form{background:#fff;border-radius:18px;padding:20px;width:min(540px,95vw);max-height:90vh;overflow:auto;box-shadow:0 25px 65px rgba(15,23,42,.35);display:flex;flex-direction:column;gap:14px}
    .cg-edit-form h3{margin:0;font-size:20px}
    .cg-edit-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(190px,1fr));gap:12px}
    .cg-edit-form label{display:flex;flex-direction:column;gap:6px;font-size:14px;font-weight:600}
    .cg-edit-form input,
    .cg-edit-form select,
    .cg-edit-form textarea{width:100%;padding:10px;border-radius:8px;border:1px solid #d4d4d8;font-size:14px;font-family:inherit}
    .cg-edit-form textarea{min-height:90px;resize:vertical}
    .cg-edit-status{font-size:13px;color:var(--muted);margin:0}
    .cg-edit-file-note{font-size:13px;color:#2563eb;margin:4px 0 0}
    .cg-edit-actions{display:flex;justify-content:flex-end;gap:10px}
    .cg-edit-actions button{padding:8px 14px;border-radius:10px;border:1px solid #d4d4d8;background:#fff;font-weight:600;cursor:pointer}
    .cg-edit-actions .primary{background:#111827;color:#fff;border-color:#111827}

    .cg-note-overlay{position:fixed;inset:0;background:rgba(15,23,42,.45);display:flex;align-items:flex-end;justify-content:center;z-index:10001}
    .cg-note-overlay.is-hidden{display:none!important}
    .cg-note-drawer{background:#fff;border-radius:18px 18px 0 0;padding:16px 18px;width:min(520px,95vw);max-height:85vh;overflow:hidden;box-shadow:0 -18px 40px rgba(15,23,42,.35);display:flex;flex-direction:column;gap:12px}
    .cg-note-header{display:flex;justify-content:space-between;align-items:center}
    .cg-note-header h3{margin:0;font-size:18px;text-align:left}
    .cg-note-close{border:1px solid #d4d4d8;background:#fff;border-radius:10px;padding:4px 8px;font-size:14px}
    .cg-note-meta{display:flex;justify-content:space-between;gap:10px;font-size:12px;color:#6b7280;font-weight:600}
    .cg-note-body{white-space:pre-wrap;border:1px solid #e5e7eb;border-radius:12px;padding:10px;max-height:45vh;overflow:auto;background:#f8fafc;font-size:14px}
    .cg-note-file{font-size:13px;color:#2563eb;text-decoration:none;font-weight:600}
    .cg-note-file.is-hidden{display:none}
    .cg-note-actions{display:flex;justify-content:flex-end;gap:10px}
    .cg-note-actions button{padding:8px 14px;border-radius:10px;border:1px solid #d4d4d8;background:#fff;font-weight:600;cursor:pointer}
    .cg-note-actions button:first-child{background:#111827;color:#fff;border-color:#111827}

    #exportRangeOverlay .cg-note-drawer{width:min(480px,95vw)}
    #exportRangeOverlay .cg-edit-grid{margin-top:4px}

    #chart-stack{display:flex;flex-direction:column;gap:16px}
    .chart-range-controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;background:#f8fafc;border:1px solid #e5e7eb;border-radius:12px;padding:10px 12px}
    .chart-range-controls label{font-weight:700}
    .chart-range-controls select{padding:6px 10px;border-radius:10px;border:1px solid #d4d4d8;background:#fff;font-weight:600}
    .chart-range-display{font-size:12px;color:#475569;font-weight:600}
    .chart-range-label{margin:-4px 0 10px;color:#475569}
    .movement-range-controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:6px 0 12px;background:#f8fafc;border:1px solid #e5e7eb;border-radius:12px;padding:8px 10px}
    .movement-range-controls label{font-weight:700}
    .movement-range-controls select{padding:6px 10px;border-radius:10px;border:1px solid #d4d4d8;background:#fff;font-weight:600}
    .movement-range-display{font-size:12px;color:#475569;font-weight:600}
    .community-types{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));}
    .community-types-card{border:1px solid #e5e7eb;border-radius:14px;padding:12px;background:#fff;box-shadow:0 8px 18px rgba(15,23,42,.07)}
    .community-types-card h3{margin:0 0 8px;font-size:16px}
    .community-types-list{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px}
    .community-types-item{display:flex;align-items:center;justify-content:space-between;gap:10px;border:1px solid #e2e8f0;border-radius:10px;padding:6px 10px;background:#f8fafc;font-weight:700}
    .community-types-label{font-size:13px;color:#111}
    .community-types-count{font-size:13px;color:#111;min-width:24px;text-align:right}
    .mood-summary-inline{margin-top:10px;border:1px solid #e5e7eb;border-radius:14px;padding:12px;background:#f8fafc}
    .mood-summary-inline h4{margin:0 0 8px;font-size:14px}
    .mood-summary-inline .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:8px}
    .mood-summary-inline .item{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:8px 10px;font-weight:700;color:#0f172a}
    .kpi-summary-inline{border:1px solid #e5e7eb;border-radius:16px;padding:16px;background:#fff;box-shadow:0 10px 30px rgba(15,23,42,.08)}
    .kpi-summary-inline h4{margin:0 0 12px;font-size:16px}
    .kpi-summary-inline .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:10px}
    .kpi-summary-inline .item{background:#f8fafc;border:1px solid #e5e7eb;border-radius:12px;padding:10px 12px;font-weight:700;color:#0f172a}
    body.print-export main.page{max-width:980px}
    body.print-export #chart-stack{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:14px;align-items:start;grid-auto-rows:minmax(260px,auto)}
    body.print-export .chart{margin:0;max-width:none;min-height:260px}
    body.print-export .chart canvas{max-height:220px!important}
    body.print-export #navbar{display:none!important}
    body.print-export #bottom-tabs,
    body.print-export .bottom-tabs,
    body.print-export .tabs.tabs--six,
    body.print-export #tabbar-host,
    body.print-export .tabbar,
    body.print-export .tabbar-host{display:none!important}
    body.print-export{padding-bottom:0!important}
    body.print-export .chart,
    body.print-export .kpi-summary-inline,
    body.print-export .mood-summary-inline{break-inside:avoid;page-break-inside:avoid}
    body.print-export #hc-root{page-break-after:always}
    body.print-export #chart-stack{page-break-before:always}
    body.print-export #mood-panel{display:none}
    body.print-export #kpi-row{display:none}
    body.print-export #cgPdfSummary{page-break-after:always}
    body.print-export #cgMonthlySummaryWrap{page-break-before:always}
    body.print-export #cgWeeklySummaryWrap,
    body.print-export #cgMonthlySummaryWrap,
    body.print-export .cg-summary-card{break-inside:avoid;page-break-inside:avoid}
    body.print-export #reportFocusPanel{padding:10px;margin:6px 0}
    body.print-export #reportFocusPanel{position:static;max-width:100%;transform:none}
    body.print-export #reportFocusPanel h2{margin:4px 0 6px;font-size:18px}
    body.print-export #reportFocusPanel h3{margin:0 0 4px;font-size:15px}
    body.print-export #reportFocusPanel .focus-goal-list{display:none}
    body.print-export #reportFocusPanel #focusGoalChart{display:none}
    body.print-export #reportFocusPanel .planner-chart-panel{margin:6px 0 10px}
    body.print-export #reportFocusPanel .practice-dot{width:22px;height:22px;font-size:11px}
    body.print-export #reportFocusPanel .practice-cell{gap:4px;font-size:11px}
    body.print-export #reportFocusPanel .planner-chart-wrap{padding:8px}
    body.print-export #cg-panel{padding:10px}
    body.print-export #cg-panel h2{margin:6px 0}
    body.print-export #cg-panel .toolbar,
    body.print-export #cg-panel .cg-advanced-filters,
    body.print-export #cg-panel #cgFilterBanner{display:none}
    body.print-export #cg-panel .cg-table-wrap{display:none}
    body.print-export .movement-panel{break-inside:avoid}
    body.print-export .movement-grid{grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
    body.print-export .movement-card{padding:10px;min-height:220px}
    body.print-export .movement-card h4{margin:0 0 6px;font-size:14px}
    body.print-export .movement-card canvas{max-height:160px!important}
    body.print-export #mood-panel .toolbar,
    body.print-export #mood-panel .mood-table-wrap{display:none}
    body.print-export #mood-panel{padding-bottom:8px}
    body.print-export .mood-summary-card{display:block}
    body.print-export #kpi-row{margin:8px 0 10px;grid-template-columns:repeat(5,minmax(0,1fr));gap:8px}
    body.print-export .kpi{padding:6px 8px;font-size:12px}
    #kpi-row{display:none}
    #mood-panel{display:none}
    body.print-export .hc-card{box-shadow:none}
    body.print-export .hc-wrap,
    body.print-export .hc-card{break-inside:avoid;page-break-inside:avoid}
    body.print-export .hc-head{padding:8px 10px;gap:8px}
    body.print-export .hc-title{font-size:16px}
    body.print-export .hc-kv{padding:6px 8px;font-size:11px}
    body.print-export .hc-kvs{display:none}
    body.print-export .hc-legend{gap:8px;padding:8px 10px;font-size:11px}
    body.print-export .hc-legend input{display:none}
    body.print-export .hc-emo{font-size:16px}
    body.print-export .hc-grid{grid-template-columns:repeat(7,minmax(70px,1fr))}
    body.print-export .hc-dow{padding:6px 4px;font-size:11px}
    body.print-export .hc-cell{min-height:70px;padding:6px}
    body.print-export .hc-date{font-size:11px}
    body.print-export .hc-icons{font-size:16px;gap:4px}
    body.print-export .pdf-only{display:block}

    body.calendar-print-only main.page > :not([data-print-section="Daily Mood & Calendar"]){display:none}
    body.calendar-print-only #mood-panel{display:none}
    body.calendar-print-only #kpi-row{display:none}
    body.calendar-print-only .hc-head .hc-btn{display:none}
    body.calendar-print-only .hc-wrap{margin:0}

    @media print{
      #navbar{display:none!important}
      .top-actions{display:none!important}
      .no-export{display:none!important}
      #bottom-tabs,
      .bottom-tabs,
      .tabs.tabs--six,
      #tabbar-host,
      .tabbar,
      .tabbar-host{display:none!important}
      body.print-export main.page{max-width:980px!important;width:980px!important}
    }

    @media (max-width:720px){
      main.page{padding:12px}
      h1{font-size:24px}
      .panel{padding:12px}
      .toolbar{flex-direction:column;align-items:stretch}
      .toolbar label{width:100%}
      .toolbar button{width:100%}
      .kpis{grid-template-columns:repeat(2,minmax(0,1fr))}
      .chart{padding:10px}
      .movement-grid{grid-template-columns:1fr}
      .movement-summary{grid-template-columns:1fr}
      .movement-card{min-height:auto}
      .cg-table-wrap{overflow:auto}
      #cgTable{min-width:780px;font-size:12px}
      #cgTable th,#cgTable td{padding:6px}
      .cg-note-drawer{width:100%;border-radius:18px 18px 0 0}
      .cg-filter-banner{flex-direction:column;align-items:flex-start}
      .cg-filter-banner button{width:100%}
      .hc-head{flex-direction:column;gap:8px;align-items:flex-start}
      .hc-kvs{flex-direction:column}
      .hc-grid{grid-template-columns:repeat(7,minmax(80px,1fr))}
      .hc-cell{min-height:90px}
      #cg-status{display:none}
      #cgNotesToggle{display:none}
      .cg-note-drawer{border-radius:18px}
    }

    body.export-wide{min-width:1200px}
    body.export-wide main.page{max-width:1200px;width:1200px}
  </style>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>document.addEventListener('DOMContentLoaded',()=>{ try{ Chart.register(ChartDataLabels); }catch(e){} });</script>
</head>
<!-- ===== MINI STATUS BAR (no console needed) ===== -->
<style>
  #cg-status{position:fixed;left:8px;right:8px;bottom:8px;z-index:9999;
    background:#fff;border:1px solid #ddd;border-radius:10px;padding:10px;
    font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial;box-shadow:0 6px 18px rgba(0,0,0,.12)}
  #cg-status .row{margin:.25rem 0}
  #cg-status .ok{color:#0f6a2f}
  #cg-status .err{color:#b00020}
  #cg-status button{margin-left:.5rem}
  #cg-status{display:none!important}
  @media (max-width: 640px){
    #cg-status{font-size:12px;padding:8px}
    #cg-status button{margin:6px 0 0 .5rem}
  }
</style>
<div id="cg-status">
  <div class="row"><b>Caregiver pipeline:</b>
    <button id="cg-run">Run test</button>
  </div>
  <div class="row" id="cg-line1"></div>
  <div class="row" id="cg-line2"></div>
</div>

<script type="module">
import { rest, getSessionFromStorage } from './restClient.js?v=2025.01.09E';

(function(){
  const Status = document.getElementById('cg-status');
  const L1 = document.getElementById('cg-line1');
  const L2 = document.getElementById('cg-line2');
  const Run = document.getElementById('cg-run');
  const say = (el, txt, cls='') => { el.className=cls; el.textContent = txt; };

  if (Status) {
    const hideBtn = document.createElement('button');
    hideBtn.textContent = 'Hide';
    hideBtn.addEventListener('click', () => { Status.style.display = 'none'; });
    hideBtn.style.marginLeft = '0.5rem';
    Status.querySelector('.row')?.appendChild(hideBtn);
  }

  async function smoke(){
    try {
      const session = getSessionFromStorage();
      if (!session?.user?.id) { say(L1,'not signed in (this domain)','err'); return; }
      say(L1,'checking authâ€¦');
      const user = session.user;
      say(L1,'auth OK','ok');

      // 2) minimal insert only to existing columns
      say(L2,'inserting test rowâ€¦');
      const d = new Date().toISOString().slice(0,10); // YYYY-MM-DD for DATE column
      await rest('caregiver_checkins', {
        method: 'POST',
        headers: { Prefer: 'return=representation' },
        body: JSON.stringify([{ user_id: user.id, date: d }]),
      });
      say(L2,'insert success âœ”','ok');
      alert('Insert success. Check caregiver_checkins for a new row dated '+d);
    } catch(e){
      console.error(e);
      say(L2, 'insert failed: ' + (e?.message || e), 'err');
      alert('Insert failed: ' + (e?.message || e));
    }
  }

  Run.addEventListener('click', smoke);
})();
</script>

<!-- Shared navigation shell -->
<script defer src="./ui-shell.js?v=2025.01.09E"></script>
<script defer src="./scripts/appbar-drawer.js?v=2025.01.09E"></script>

<body>
  <div id="navbar"></div>
  <div class="top-actions no-export" style="display:flex;gap:8px;justify-content:center;margin:8px 0 14px;">
    <button id="fullExportBtn">ğŸ“„ Export Full Report (PDF)</button>
    <button id="fullShareBtn">ğŸ“¤ Share Full Report (PDF)</button>
    <button id="fullPrintBtn">ğŸ–¨ï¸ Print</button>
    <button id="calendarPrintBtn">ğŸ—“ï¸ Print Calendar Only</button>
  </div>

  <main class="page">
    <h1>Reports</h1>

    <div data-print-section="Caregiver Overview">
    <section class="panel focus-board" id="reportFocusPanel">
      <h2>Weekly Focus</h2>
      <p id="reportFocusSummary" class="muted">Loading weekly focusâ€¦</p>
      <div id="focusPdfSummary" class="focus-pdf-summary pdf-only">
        <div class="focus-pdf-title" id="focusPdfTitle">Weekly Focus</div>
        <div class="focus-pdf-body" id="focusPdfBody">â€”</div>
        <div class="focus-pdf-stats" id="focusPdfStats">â€”</div>
      </div>
      <div id="plannerChartSection" class="planner-chart-panel is-hidden">
        <h3>Weekly Focus</h3>
        <p id="focusPlannerStats" class="muted is-hidden" style="margin:-6px 0 8px"></p>
        <div id="plannerChartWrap" class="planner-chart-wrap compact is-hidden">
          <div id="plannerRow" class="practice-row" aria-label="Weekly practice tracker"></div>
        </div>
      </div>
      <ul id="reportFocusGoals" class="focus-goal-list"></ul>
      <canvas id="focusGoalChart" height="220"></canvas>
    </section>
    <section class="panel" id="cg-panel">
      <h2>Caregiver Check-Ins</h2>

      <div class="toolbar">
        <label>From <input type="date" id="cgStart"></label>
        <label>To <input type="date" id="cgEnd"></label>
        <button id="cgApply" type="button">Apply</button>

        <div class="toolbar-actions">
          <button id="cgNotesToggle" type="button" class="no-export" aria-pressed="false">Expand notes</button>
          <button id="cgQuickLookToggle" type="button" class="no-export" aria-controls="cgQuickLook" aria-expanded="false">âš¡ Quick Look</button>
          <button id="cgPdf"  class="no-export">ğŸ“„ PDF</button>
          <button id="cgSharePdf" class="no-export">ğŸ“¤ Share PDF</button>
        </div>
      </div>

      <div id="cgFilterBanner" class="cg-filter-banner is-hidden" role="status" aria-live="polite">
        <span>Filtered: Caregiver = <strong id="cgFilterLabel">All caregivers</strong></span>
        <button type="button" class="cg-clear-filters">Clear Filter(s)</button>
      </div>

      <details class="cg-advanced-filters">
        <summary>Advanced Filters</summary>
        <div class="cg-filter-grid">
          <label>Caregiver
            <select id="cgCaregiver">
              <option value="all">All caregivers</option>
            </select>
          </label>
          <button type="button" class="cg-clear-filters">Clear Filter(s)</button>
        </div>
      </details>

      <div id="cgQuickLook" class="quick-look is-hidden" role="region" aria-live="polite">
        <div class="quick-look-head">
          <div>
            <div class="quick-look-label">Quick Look</div>
            <div class="quick-look-subtitle">Last five caregiver days (respects filters)</div>
          </div>
          <button id="cgQuickLookClose" type="button" aria-label="Exit Quick Look" class="no-export">Exit</button>
        </div>
        <div id="cgQuickLookContent" class="quick-look-content"></div>
        <p id="cgQuickLookEmpty" class="muted" style="margin:0">Need caregiver check-ins to build this snapshot.</p>
      </div>
      <div id="cgQuickLookPrint" class="quick-look-print-sheet is-hidden"></div>

      <div class="cg-table-wrap cg-hide-when-quick-look" style="max-height:340px;overflow:auto;border-radius:8px">
        <table id="cgTable">
          <thead>
            <tr>
              <th>Timestamp</th>
              <th>Caregiver</th>
              <th>Hygiene</th>
              <th>Food</th>
              <th>Clean-up</th>
              <th>Voc (min)</th>
              <th>Comm (min)</th>
              <th>Prompt</th>
              <th>Notes</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="cgTbody"><tr><td colspan="10">Loadingâ€¦</td></tr></tbody>
        </table>
      </div>

      <p class="muted cg-hide-when-quick-look" id="cgCount"></p>

      <div id="cgPdfSummary" class="pdf-only">
        <div id="cgWeeklySummaryWrap">
          <h3>Caregiver Summary (Weekly)</h3>
          <div id="cgWeeklySummary" class="cg-summary-grid"></div>
        </div>
        <div id="cgMonthlySummaryWrap">
          <h3>Caregiver Summary (Monthly)</h3>
          <div id="cgMonthlySummary" class="cg-summary-grid"></div>
        </div>
      </div>

      <div id="cgNoteOverlay" class="cg-note-overlay is-hidden" role="dialog" aria-modal="true" aria-labelledby="cgNoteTitle">
        <div class="cg-note-drawer">
          <div class="cg-note-header">
            <h3 id="cgNoteTitle">Caregiver Note</h3>
            <button type="button" id="cgNoteClose" class="cg-note-close" aria-label="Close note">âœ•</button>
          </div>
          <div class="cg-note-meta">
            <span id="cgNoteTimestamp">â€”</span>
            <span id="cgNoteCaregiver">â€”</span>
          </div>
          <div class="cg-note-body" id="cgNoteBody"></div>
          <a id="cgNoteFile" class="cg-note-file is-hidden" href="#" target="_blank" rel="noopener">View attached file</a>
          <div class="cg-note-actions">
            <button type="button" id="cgNoteEdit">Edit</button>
            <button type="button" id="cgNoteCloseFooter">Close</button>
          </div>
        </div>
      </div>

      <div class="movement-panel">
        <h3>Movement Symptoms</h3>
        <p class="movement-sub" id="movementRangeLabel">Summary for selected date range</p>
        <div class="movement-range-controls no-export">
          <label for="movementRangeSelect">Movement range</label>
          <select id="movementRangeSelect">
            <option value="day">Day</option>
            <option value="week">Week</option>
            <option value="month" selected>Month</option>
            <option value="year">Year</option>
            <option value="all">All time</option>
          </select>
          <span class="movement-range-display" id="movementRangeDisplay">Showing: Month</span>
        </div>
        <div class="movement-summary" id="movementSummary">
          <div class="movement-card">
            <div class="row"><span class="label">Days with symptoms</span><span class="value" id="movementDaysVal">â€”</span></div>
            <div class="row"><span class="label">Avg severity</span><span class="value" id="movementAvgVal">â€”</span></div>
            <div class="row"><span class="label">Max severity</span><span class="value" id="movementMaxVal">â€”</span></div>
            <div class="row"><span class="label">Most common type</span><span class="value" id="movementTypeVal">â€”</span></div>
            <div class="row"><span class="label">Most common time</span><span class="value" id="movementTimeVal">â€”</span></div>
          </div>
        </div>
        <div class="movement-grid">
          <div class="movement-card">
            <h4>Movement Severity (sparkline)</h4>
            <canvas id="movementSeverityChart"></canvas>
          </div>
          <div class="movement-card">
            <h4>Main Type (Top 5)</h4>
            <canvas id="movementMainTypeChart"></canvas>
          </div>
          <div class="movement-card">
            <h4>Body Map (Top 5)</h4>
            <canvas id="movementBodyMapChart"></canvas>
          </div>
          <div class="movement-card">
            <h4>Triggers (Top 5)</h4>
            <canvas id="movementTriggerChart"></canvas>
          </div>
        </div>
      </div>
    </section>
    </div>

    <div id="cgEditOverlay" class="cg-edit-overlay is-hidden" role="dialog" aria-modal="true" aria-labelledby="cgEditTitle">
      <form id="cgEditForm" class="cg-edit-form">
        <h3 id="cgEditTitle">Edit Caregiver Check-In</h3>
        <p id="cgEditStatus" class="cg-edit-status">Select a row to load its Supabase data.</p>
        <div class="cg-edit-grid">
          <label>Entry date
            <input type="date" id="cgEditDate" name="entry_date">
          </label>
          <label>Entry time
            <input type="time" id="cgEditTime" name="entry_time" step="60">
          </label>
          <label>Fell asleep at
            <input type="time" id="cgEditSleepTime" name="sleep_onset_time" step="60">
          </label>
          <label>Had a BM?
            <select id="cgEditBm" name="had_bm">
              <option value="">Selectâ€¦</option>
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </label>
          <label>Anomaly flag
            <select id="cgEditAnomaly" name="anomaly_flag">
              <option value="">Selectâ€¦</option>
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </label>
          <label>Hygiene
            <select id="cgEditHygiene" name="hygiene">
              <option value="">Selectâ€¦</option>
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </label>
          <label>Food prep
            <select id="cgEditFoodPrep" name="food_prep">
              <option value="">Selectâ€¦</option>
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </label>
          <label>Clean-up
            <select id="cgEditCleanup" name="cleanup">
              <option value="">Selectâ€¦</option>
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </label>
          <label>Vocational minutes
            <input type="number" id="cgEditVoc" name="vocational_time" min="0" step="1" placeholder="e.g., 60">
          </label>
          <label>Community minutes
            <input type="number" id="cgEditCommunity" name="community_time" min="0" step="1" placeholder="e.g., 45">
          </label>
          <label>Prompt level (0â€“4)
            <input type="number" id="cgEditSkill" name="new_skill_score" min="0" max="4" step="1" placeholder="0â€“4">
          </label>
        </div>
        <label>Caregiver notes
          <textarea id="cgEditNotes" name="caregiver_notes" placeholder="Add notes about the dayâ€¦"></textarea>
        </label>
        <label>Attachment
          <input type="file" id="cgEditFile" name="file" accept="image/*,.pdf,.doc,.docx,.txt">
          <span id="cgEditFileNote" class="cg-edit-file-note">No file uploaded for this entry.</span>
        </label>
        <input type="hidden" id="cgEditId" name="checkin_id">
        <div class="cg-edit-actions">
          <button type="button" id="cgEditCancel">Cancel</button>
          <button type="submit" class="primary" id="cgEditSave">Save Changes</button>
        </div>
      </form>
    </div>

    <!-- Keep: Daily Mood Check-Ins (table) -->
    <div data-print-section="Daily Mood & Calendar">
    <section class="panel" id="mood-panel">
      <h2>Daily Mood Check-Ins</h2>
      <div class="toolbar">
        <label>View Mood Totals By:
          <select id="moodRange">
            <option value="day">Day</option>
            <option value="month">Month</option>
            <option value="year">Year</option>
            <option value="6months">6 Months</option>
            <option value="all" selected>All Time</option>
          </select>
        </label>
        <button id="exportMoodBtn">ğŸ“„ Export Mood Check-Ins to PDF</button>
      </div>

      <div class="mood-table-wrap" style="max-height:340px;overflow:auto;border-radius:8px">
        <table id="moodTable">
          <thead><tr><th>Timestamp</th><th>Mood</th><th>Intensity</th><th>Notes</th></tr></thead>
          <tbody><tr><td colspan="4">Loadingâ€¦</td></tr></tbody>
        </table>
      </div>
      <div id="moodSummaryCard" class="mood-summary-card">
        <div class="mood-summary-title">Mood Summary</div>
        <div class="mood-summary-grid">
          <div><span class="label">Total check-ins</span><span class="value" id="moodSummaryTotal">â€”</span></div>
          <div><span class="label">Most common mood</span><span class="value" id="moodSummaryCommon">â€”</span></div>
          <div><span class="label">Positive</span><span class="value" id="moodSummaryPositive">â€”</span></div>
          <div><span class="label">Challenging</span><span class="value" id="moodSummaryChallenging">â€”</span></div>
        </div>
      </div>
    </section>

    <!-- KPIs (percentages + totals) -->
    <div class="kpis" id="kpi-row">
      <div class="kpi"><div class="label">Total Entries</div><div class="value" id="kpi-entries">â€”</div></div>
      <div class="kpi"><div class="label">Hygiene % Yes</div><div class="value" id="kpi-hygiene">â€”</div></div>
      <div class="kpi"><div class="label">Food % Yes</div><div class="value" id="kpi-food">â€”</div></div>
      <div class="kpi"><div class="label">Clean-up % Yes</div><div class="value" id="kpi-cleanup">â€”</div></div>
      <div class="kpi"><div class="label">Total Vocational (min)</div><div class="value" id="kpi-voc">â€”</div></div>
      <div class="kpi"><div class="label">Total Community (min)</div><div class="value" id="kpi-com">â€”</div></div>
      <div class="kpi"><div class="label">Avg Prompt Level</div><div class="value" id="kpi-prompt">â€”</div></div>
      <div class="kpi"><div class="label">Movement Symptom Days</div><div class="value" id="kpi-move-days">â€”</div></div>
      <div class="kpi"><div class="label">Avg Movement Severity</div><div class="value" id="kpi-move-avg">â€”</div></div>
      <div class="kpi"><div class="label">Max Movement Severity</div><div class="value" id="kpi-move-max">â€”</div></div>
    </div>

    <div class="calendar-insights" id="calendarInsights">
      <section class="calendar-card" aria-labelledby="calendarQuickLookTitle">
        <h3 id="calendarQuickLookTitle">Calendar Quick Look</h3>
        <p class="calendar-sub">Month: <span id="calendarQuickLookMonth">â€”</span></p>
        <ul id="calendarQuickLookList" class="calendar-quick-list"></ul>
        <p id="calendarQuickLookEmpty" class="muted" style="margin:10px 0 0">Add health notes to see a monthly snapshot.</p>
      </section>
      <section class="calendar-card" aria-labelledby="monthlyShiftsTitle">
        <h3 id="monthlyShiftsTitle">Monthly Shifts</h3>
        <p class="calendar-sub">Full months: <span id="monthlyShiftMonths">â€”</span></p>
        <div id="monthlyShiftList" class="monthly-shifts-list"></div>
        <p id="monthlyShiftEmpty" class="muted" style="margin:10px 0 0">Need a few months of calendar data to compare trends.</p>
      </section>
    </div>

    <!-- Health calendar -->
    <section id="hc-root" class="hc-wrap">
      <div class="hc-card">
        <div class="hc-head">
          <div class="hc-row">
            <button class="hc-btn" id="hc-prev" aria-label="Previous month">â€¹</button>
            <div class="hc-title" id="hc-monthTitle">Loadingâ€¦</div>
            <button class="hc-btn" id="hc-next" aria-label="Next month">â€º</button>
          </div>
          <div class="hc-row no-export">
            <button class="hc-btn" id="hcPrintBtn" type="button">ğŸ–¨ï¸ Print Calendar</button>
            <button class="hc-btn" id="hcShareBtn" type="button">ğŸ“¤ Share Calendar PDF</button>
          </div>
          <div class="hc-kvs">
            <div class="hc-kv" id="hc-kv-bm">ğŸ’© BM days: 0</div>
            <div class="hc-kv" id="hc-kv-sleep">ğŸ˜´ GOOD SLEEP (MORE, 8+ hours) days: 0</div>
            <div class="hc-kv" id="hc-kv-sleep-low">ğŸ˜ª Poor sleep (MINUS 8 hours) days: 0</div>
            <div class="hc-kv" id="hc-kv-onset">ğŸ¦‰ Late sleep onset days: 0</div>
            <div class="hc-kv" id="hc-kv-night">ğŸŒ™ Night waking days: 0</div>
            <div class="hc-kv" id="hc-kv-prn-sleep">ğŸ’ŠS PRN sleep days: 0</div>
            <div class="hc-kv" id="hc-kv-prn-mania">ğŸ’ŠM PRN mania days: 0</div>
            <div class="hc-kv" id="hc-kv-prn-aggr">ğŸ’ŠA PRN aggression days: 0</div>
            <div class="hc-kv" id="hc-kv-tired">ğŸ¥± Appears tired days: 0</div>
            <div class="hc-kv" id="hc-kv-manic">âš¡ï¸ Manic days: 0</div>
            <div class="hc-kv" id="hc-kv-sick">ğŸ¤’ Sick days: 0</div>
            <div class="hc-kv" id="hc-kv-temp">ğŸŒ¡ï¸ Temperature days: 0</div>
            <div class="hc-kv" id="hc-kv-med-change">ğŸ“âœï¸ Med change days: 0</div>
            <div class="hc-kv" id="hc-kv-appetite">ğŸ½ï¸ Appetite change days: 0</div>
            <div class="hc-kv" id="hc-kv-anomaly">ğŸš© Anomaly days: 0</div>
          </div>
        </div>

        <div class="hc-legend hc-row" style="border-top:0">
          <label><input type="checkbox" data-hc-layer="bm" checked/> <span class="hc-emo" aria-hidden="true">ğŸ’©</span> BM</label>
          <label><input type="checkbox" data-hc-layer="sleep" checked/> <span class="hc-emo" aria-hidden="true">ğŸ˜´</span> GOOD SLEEP (MORE, 8+ hours)</label>
          <label><input type="checkbox" data-hc-layer="sleep_low" checked/> <span class="hc-emo" aria-hidden="true">ğŸ˜ª</span> Poor sleep (MINUS 8 hours)</label>
          <label><input type="checkbox" data-hc-layer="onset" checked/> <span class="hc-emo" aria-hidden="true">ğŸ¦‰</span> Late sleep onset</label>
          <label><input type="checkbox" data-hc-layer="night" checked/> <span class="hc-emo" aria-hidden="true">ğŸŒ™</span> Night waking</label>
          <label><input type="checkbox" data-hc-layer="prn_sleep" checked/> <span class="hc-emo" aria-hidden="true">ğŸ’ŠS</span> PRN sleep</label>
          <label><input type="checkbox" data-hc-layer="prn_mania" checked/> <span class="hc-emo" aria-hidden="true">ğŸ’ŠM</span> PRN mania</label>
          <label><input type="checkbox" data-hc-layer="prn_aggr" checked/> <span class="hc-emo" aria-hidden="true">ğŸ’ŠA</span> PRN aggression</label>
          <label><input type="checkbox" data-hc-layer="tired" checked/> <span class="hc-emo" aria-hidden="true">ğŸ¥±</span> Appears tired</label>
          <label><input type="checkbox" data-hc-layer="manic" checked/> <span class="hc-emo" aria-hidden="true">âš¡ï¸</span> Manic</label>
          <label><input type="checkbox" data-hc-layer="sick" checked/> <span class="hc-emo" aria-hidden="true">ğŸ¤’</span> Sick</label>
          <label><input type="checkbox" data-hc-layer="temp" checked/> <span class="hc-emo" aria-hidden="true">ğŸŒ¡ï¸</span> Temperature</label>
          <label><input type="checkbox" data-hc-layer="med_change" checked/> <span class="hc-emo" aria-hidden="true">ğŸ“âœï¸</span> Med change</label>
          <label><input type="checkbox" data-hc-layer="appetite" checked/> <span class="hc-emo" aria-hidden="true">ğŸ½ï¸</span> Appetite change</label>
          <label><input type="checkbox" data-hc-layer="moon" checked/> <span class="hc-emo" aria-hidden="true">ğŸŒ•</span> Full moon</label>
          <label><input type="checkbox" data-hc-layer="anomaly" checked/> <span class="hc-emo" aria-hidden="true">ğŸš©</span> Anomaly</label>
        </div>

        <div class="hc-grid" id="hc-grid" role="grid" aria-label="Health calendar"></div>
      </div>
    </section>
    </div>

    <!-- Charts -->
    <section id="chart-stack" data-print-section="Trends & Charts">
    <div class="chart-range-controls no-export">
      <label for="chartRangeSelect">Chart range</label>
      <select id="chartRangeSelect">
        <option value="day">Day</option>
        <option value="week">Week</option>
        <option value="month" selected>Month</option>
        <option value="year">Year</option>
        <option value="all">All time</option>
      </select>
      <span class="chart-range-display" id="chartRangeDisplay">Showing: Month</span>
    </div>
    <div class="chart kpi-summary-inline">
      <h4>Caregiver Check-In Totals</h4>
      <div class="grid">
        <div class="item">Total entries <span id="kpi-entries-inline">â€”</span></div>
        <div class="item">Hygiene % Yes <span id="kpi-hygiene-inline">â€”</span></div>
        <div class="item">Food % Yes <span id="kpi-food-inline">â€”</span></div>
        <div class="item">Clean-up % Yes <span id="kpi-cleanup-inline">â€”</span></div>
        <div class="item">Total Vocational (min) <span id="kpi-voc-inline">â€”</span></div>
        <div class="item">Total Community (min) <span id="kpi-com-inline">â€”</span></div>
        <div class="item">Avg Prompt Level <span id="kpi-prompt-inline">â€”</span></div>
        <div class="item">Movement Symptom Days <span id="kpi-move-days-inline">â€”</span></div>
        <div class="item">Avg Movement Severity <span id="kpi-move-avg-inline">â€”</span></div>
        <div class="item">Max Movement Severity <span id="kpi-move-max-inline">â€”</span></div>
      </div>
    </div>
    <div class="chart">
      <h2>Physical & Daily Living Overview (Monthly Totals)</h2>
      <p class="muted chart-range-label" id="healthRangeLabel">Range: Month</p>
      <canvas id="healthChart"></canvas>
      <p class="muted">Counts of caregiver check-ins where each category was marked â€œYesâ€. Use this to spot over- or under-focused areas.</p>
    </div>
      <div class="chart">
        <h2>Prompt Level Over Time</h2>
        <p class="muted chart-range-label" id="promptRangeLabel">Range: Month</p>
        <canvas id="skillChart"></canvas>
        <p class="muted">Average prompt level (0â€“4) per day from caregiver check-ins, rounded to whole numbers. Higher = more prompting needed.</p>
      </div>
      <div class="chart">
        <h2>Community Interaction Types</h2>
        <p class="muted chart-range-label" id="communityInteractionRangeLabel">Range: Month</p>
        <canvas id="communityInteractionChart"></canvas>
        <p class="muted">Counts of interaction types when community engagement was reported.</p>
      </div>
      <div class="chart">
        <h2>Activity Types (Top 6)</h2>
        <p class="muted chart-range-label" id="communityTypesRangeLabel">Range: Month</p>
        <div class="community-types">
          <div class="community-types-card">
            <h3>Home / Community</h3>
            <ul id="communityTypesHome" class="community-types-list"></ul>
          </div>
          <div class="community-types-card">
            <h3>Community-at-large</h3>
            <ul id="communityTypesPublic" class="community-types-list"></ul>
          </div>
        </div>
      </div>
      <div class="chart">
        <h2>Individual Mood Share (Pie)</h2>
        <canvas id="moodPieMain"></canvas>
        <div class="mood-summary-inline">
          <h4>Daily Mood Summary</h4>
          <div class="grid">
            <div class="item">Total check-ins <span id="moodSummaryTotalInline">â€”</span></div>
            <div class="item">Most common mood <span id="moodSummaryCommonInline">â€”</span></div>
            <div class="item">Positive <span id="moodSummaryPositiveInline">â€”</span></div>
            <div class="item">Challenging <span id="moodSummaryChallengingInline">â€”</span></div>
          </div>
        </div>
      </div>

      <div class="chart">
        <h2>Engagement vs Mood â€” Average Minutes by Activity</h2>
        <p class="muted chart-range-label" id="engagementRangeLabel">Range: Month</p>
        <canvas id="engagementVsMood"></canvas>
        <p class="muted">X = Mood bucket. Y = Average minutes. Bars = Home / Vocational / Community / Leisure.</p>
      </div>

      <div class="chart small">
        <h2 style="margin:0 0 8px;">Leisure (Would-You-Rather) â€” Minutes & Picks</h2>
        <canvas id="wyrBar" height="220"></canvas>
        <div id="wyrGraphic" class="wyr-graphic is-hidden" aria-hidden="true">
          <svg viewBox="0 0 520 260" role="img" aria-label="Leisure minutes mock chart">
            <rect x="0" y="0" width="520" height="260" fill="#fff"/>
            <!-- Axes -->
            <line x1="60" y1="20" x2="60" y2="220" stroke="#cbd5e1" stroke-width="1"/>
            <line x1="60" y1="220" x2="500" y2="220" stroke="#cbd5e1" stroke-width="1"/>
            <!-- Y grid + labels -->
            <g fill="#6b7280" font-size="12" font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial">
              <text x="28" y="220" text-anchor="end">0</text>
              <text x="28" y="175" text-anchor="end">30</text>
              <text x="28" y="130" text-anchor="end">60</text>
              <text x="28" y="85" text-anchor="end">90</text>
              <text x="28" y="40" text-anchor="end">120</text>
            </g>
            <g stroke="#e5e7eb" stroke-width="1">
              <line x1="60" y1="175" x2="500" y2="175"/>
              <line x1="60" y1="130" x2="500" y2="130"/>
              <line x1="60" y1="85" x2="500" y2="85"/>
              <line x1="60" y1="40" x2="500" y2="40"/>
            </g>
            <!-- Bars -->
            <g fill="#fbbf24">
              <rect x="90"  y="90"  width="60" height="130" rx="6"/>  <!-- Puzzles -->
              <rect x="190" y="60"  width="60" height="160" rx="6"/>  <!-- Music -->
              <rect x="290" y="110" width="60" height="110" rx="6"/>  <!-- Walking -->
              <rect x="390" y="70"  width="60" height="150" rx="6"/>  <!-- Books on tape -->
            </g>
            <!-- Picks line -->
            <g fill="none" stroke="#60a5fa" stroke-width="3">
              <path d="M120 140 L220 120 L320 155 L420 130"/>
            </g>
            <g fill="#60a5fa">
              <circle cx="120" cy="140" r="4"/>
              <circle cx="220" cy="120" r="4"/>
              <circle cx="320" cy="155" r="4"/>
              <circle cx="420" cy="130" r="4"/>
            </g>
            <!-- X labels -->
            <g fill="#111827" font-size="12" font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial">
              <text x="120" y="240" text-anchor="middle">Puzzles</text>
              <text x="220" y="240" text-anchor="middle">Music</text>
              <text x="320" y="240" text-anchor="middle">Walking</text>
              <text x="420" y="240" text-anchor="middle">Books on tape</text>
            </g>
            <!-- Y title -->
            <text x="14" y="24" transform="rotate(-90 14 24)" fill="#6b7280" font-size="12" font-family="system-ui, -apple-system, Segoe UI, Roboto, Arial">Minutes</text>
          </svg>
        </div>
        <p class="muted" id="wyrNote">Bars = total leisure minutes credited to each choice; line = number of picks.</p>
      </div>
    </section>
  </main>

  <div id="hc-editor-overlay" class="hc-editor-overlay is-hidden">
    <form id="hcEditorForm" class="hc-editor">
      <h3 id="hcEditorDate">Edit day</h3>
      <label>
        Quick tag
        <select id="hcEditorQuickTag">
          <option value="">Chooseâ€¦</option>
          <option value="bm">BM</option>
          <option value="sleep">Good sleep (more, 8+ hours)</option>
          <option value="sleep_low">Poor sleep (minus 8 hours)</option>
          <option value="onset">Late sleep onset</option>
          <option value="night">Night waking</option>
          <option value="prn_sleep">PRN sleep (S)</option>
          <option value="prn_mania">PRN mania (M)</option>
          <option value="prn_aggr">PRN aggression (A)</option>
          <option value="tired">Appears tired</option>
          <option value="manic">Manic</option>
          <option value="sick">Sick</option>
          <option value="temp">Temperature</option>
          <option value="med_change">Med change</option>
          <option value="moon">Full moon</option>
          <option value="appetite">Change in appetite</option>
          <option value="anomaly">Anomaly</option>
        </select>
      </label>
      <fieldset>
        <label><input type="checkbox" name="bm"> ğŸ’© BM</label>
        <label><input type="checkbox" name="sleep"> ğŸ˜´ Good sleep (more, 8+ hours)</label>
        <label><input type="checkbox" name="sleep_low"> ğŸ˜ª Poor sleep (minus 8 hours)</label>
        <label><input type="checkbox" name="onset"> ğŸ¦‰ Late sleep onset</label>
        <label><input type="checkbox" name="night"> ğŸŒ™ Night waking</label>
        <label><input type="checkbox" name="prn_sleep"> ğŸ’ŠS PRN sleep</label>
        <label><input type="checkbox" name="prn_mania"> ğŸ’ŠM PRN mania</label>
        <label><input type="checkbox" name="prn_aggr"> ğŸ’ŠA PRN aggression</label>
        <label><input type="checkbox" name="tired"> ğŸ¥± Appears tired</label>
        <label><input type="checkbox" name="manic"> âš¡ï¸ Manic</label>
        <label><input type="checkbox" name="sick"> ğŸ¤’ Sick</label>
        <label><input type="checkbox" name="temp"> ğŸŒ¡ï¸ Temperature</label>
        <label><input type="checkbox" name="med_change"> ğŸ“âœï¸ Med change</label>
        <label><input type="checkbox" name="moon"> ğŸŒ• Full moon</label>
        <label><input type="checkbox" name="appetite"> ğŸ½ï¸ Change in appetite</label>
        <label><input type="checkbox" name="anomaly"> ğŸš© Anomaly</label>
      </fieldset>
      <label>
        Sleep hours
        <input type="number" id="hcEditorSleepHours" name="sleepHours" min="0" max="24" step="0.25" placeholder="e.g. 8.5">
      </label>
      <label>
        Notes
        <textarea id="hcEditorNotes" name="notes" placeholder="Optional note for this day"></textarea>
      </label>
      <div class="actions">
        <button type="button" id="hcEditorCancel">Cancel</button>
        <button type="submit" class="primary">Save</button>
      </div>
    </form>
  </div>

  <div id="exportRangeOverlay" class="cg-note-overlay is-hidden" role="dialog" aria-modal="true" aria-labelledby="exportRangeTitle">
    <div class="cg-note-drawer">
      <div class="cg-note-header">
        <h3 id="exportRangeTitle">Export Date Range</h3>
        <button type="button" id="exportRangeClose" class="cg-note-close" aria-label="Close">âœ•</button>
      </div>
      <div class="cg-note-meta">
        <span>Choose the date window for the full report PDF.</span>
      </div>
      <div class="cg-edit-grid">
        <label>From
          <input type="date" id="exportRangeStart">
        </label>
        <label>To
          <input type="date" id="exportRangeEnd">
        </label>
      </div>
      <div class="cg-note-actions">
        <button type="button" id="exportRangeCancel">Cancel</button>
        <button type="button" id="exportRangeApply" class="primary">Export PDF</button>
      </div>
    </div>
  </div>

  <!-- Single, clean module script -->
  <script type="module">
    import { rest, getSessionFromStorage } from './restClient.js?v=2025.01.09E';
    import { SUPABASE_URL, SUPABASE_ANON_KEY } from './supabaseClient.js?v=2025.01.09E';
    import { loadFocusForCurrentUser, readLocalFocusDraft } from './focus-data.js?v=2025.01.09E';

    /* =============== Optional live data =============== */
    let loadFromSupabase = null;
    let formatEntryForList = null;
    try {
      const mod = await import('./caregiver-report-supabase.js?v=2025.01.09E');
      loadFromSupabase = mod.loadCaregiverCheckins;
      formatEntryForList = mod.formatEntryForList;
    } catch (err) {
      console.warn('[REPORT] caregiver-report-supabase.js not available', err);
    }

    // Supabase client + session gate
    const session = getSessionFromStorage();
    if (!session?.user?.id) { window.location.href = 'login.html'; throw new Error('No session'); }
    const USER_ID = session.user.id;
    window.rest = rest;

    /* =================== Utilities =================== */
    const $ = sel => document.querySelector(sel);
    const charts = {};
    const destroy = key => { charts[key]?.destroy?.(); charts[key]=null; };
    const dayKey = d => new Date(d.getFullYear(), d.getMonth(), d.getDate()).toISOString().slice(0,10);
    const axisTitle = text => ({ title:{display:true,text} });
    const RANGE_LIMITS = { day: 1, week: 7, month: 30, year: 365, all: Infinity };
    const CAREGIVER_DATE_REGEX = /^\d{4}-\d{2}-\d{2}$/;
    const parseCaregiverDate = (value) => {
      if (!value && value !== 0) return null;
      if (value instanceof Date) {
        return Number.isNaN(value.getTime()) ? null : value;
      }
      const str = String(value).trim();
      if (!str) return null;
      if (CAREGIVER_DATE_REGEX.test(str)) {
        const dt = new Date(`${str}T00:00:00`);
        return Number.isNaN(dt.getTime()) ? null : dt;
      }
      const dt = new Date(str);
      return Number.isNaN(dt.getTime()) ? null : dt;
    };
    // Converts Supabase timestamps (stored in UTC) into concise local strings so dates don't appear one day ahead.
    const formatLocalDate = (value) => {
      const dt = parseCaregiverDate(value);
      if (!dt) return null;
      return dt.toLocaleDateString(undefined, { month: 'short', day: '2-digit', year: 'numeric' });
    };
    // Normalizes any timestamp into a YYYY-MM-DD key in the viewer's timezone so grouping respects local days.
    const localDateKey = (value) => {
      const dt = parseCaregiverDate(value);
      if (!dt) return null;
      const month = String(dt.getMonth() + 1).padStart(2, '0');
      const day = String(dt.getDate()).padStart(2, '0');
      return `${dt.getFullYear()}-${month}-${day}`;
    };
    const formatLocalDateTimeLabel = (value) => {
      const dt = parseCaregiverDate(value);
      if (!dt) return 'â€”';
      const dateLabel = formatLocalDate(dt) || dt.toLocaleDateString();
      const timeLabel = dt.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' });
      return `${dateLabel} â€¢ ${timeLabel}`;
    };
    const formatDateInputValue = (date) => {
      const dt = parseCaregiverDate(date);
      if (!dt) return '';
      const y = dt.getFullYear();
      const m = String(dt.getMonth() + 1).padStart(2, '0');
      const d = String(dt.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    };
    const formatTimeInputValue = (date) => {
      const dt = parseCaregiverDate(date);
      if (!dt) return '';
      const h = String(dt.getHours()).padStart(2, '0');
      const min = String(dt.getMinutes()).padStart(2, '0');
      return `${h}:${min}`;
    };
    const GROUP_KEY = 'currentGroupId';
    const getCurrentGroupId = () => localStorage.getItem(GROUP_KEY) || null;

    async function ensureActiveGroupId(userId){
      let gid = getCurrentGroupId();
      if (gid) return gid;
      if (!userId) return null;
      try {
        const rows = await rest([
          'group_members?select=group_id',
          `user_id=eq.${encodeURIComponent(userId)}`,
          'order=joined_at.asc',
          'limit=1'
        ].join('&'));
        gid = rows?.[0]?.group_id || null;
        if (gid) {
          try { localStorage.setItem(GROUP_KEY, gid); } catch {}
        }
      } catch (error) {
        console.warn('ensureActiveGroupId error', error);
      }
      return gid;
    }

    const parseMovementBool = (value) => {
      if (value === true || value === false) return value;
      if (value == null) return null;
      const norm = String(value).trim().toLowerCase();
      if (!norm) return null;
      if (['yes','true','1','y'].includes(norm)) return true;
      if (['no','false','0','n'].includes(norm)) return false;
      return null;
    };
    const parseMovementArray = (value) => {
      if (!value) return [];
      if (Array.isArray(value)) return value.filter(Boolean);
      if (typeof value === 'string') {
        try {
          const parsed = JSON.parse(value);
          return Array.isArray(parsed) ? parsed.filter(Boolean) : [];
        } catch {
          return value.split(',').map((item) => item.trim()).filter(Boolean);
        }
      }
      return [];
    };
    const movementFromEntry = (entry) => {
      const payload = entry?.payload || {};
      const presentRaw = parseMovementBool(entry.movement_present ?? payload.movement_present);
      const severity = pickNumber(entry.movement_severity, payload.movement_severity);
      const mainType = entry.movement_main_type ?? payload.movement_main_type ?? null;
      const bodyMap = parseMovementArray(entry.movement_body_map ?? payload.movement_body_map);
      const triggers = parseMovementArray(entry.movement_triggers ?? payload.movement_triggers);
      const times = parseMovementArray(entry.movement_times ?? payload.movement_times);
      const hasDetails = Boolean(
        severity !== null ||
        mainType ||
        bodyMap.length ||
        triggers.length ||
        times.length
      );
      const present = presentRaw === null ? hasDetails : (presentRaw || hasDetails);
      return {
        present,
        severity,
        mainType,
        bodyMap,
        triggers,
      };
    };
    const dayKeyFor = (entry) => {
      const raw = entry.date || entry.timestamp || entry.created_at || entry.submitted_at;
      const dt = parseCaregiverDate(raw);
      if (!dt) return null;
      const y = dt.getFullYear();
      const m = String(dt.getMonth() + 1).padStart(2, '0');
      const d = String(dt.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    };

    function summarizeEntries(entries){
      const yesNo = key => {
        const vals = entries.map(e => e[key]).filter(v => v === true || v === false);
        const y = vals.filter(Boolean).length;
        return vals.length ? Math.round((100 * y) / vals.length) : 0;
      };
      const sum = key => entries.reduce((acc, cur) => acc + (Number(cur[key] || 0)), 0);
      const promptVals = entries
        .map((entry) => getPromptValue(entry))
        .filter((val) => Number.isFinite(val));
      const promptAvg = promptVals.length
        ? Math.round(promptVals.reduce((a, b) => a + b, 0) / promptVals.length)
        : 'â€”';
      const movementDays = new Set();
      const movementSeverities = [];
      entries.forEach((entry) => {
        const movement = movementFromEntry(entry);
        if (movement.present) {
          const dayKey = dayKeyFor(entry);
          if (dayKey) movementDays.add(dayKey);
          if (movement.severity !== null) movementSeverities.push(movement.severity);
        }
      });
      const movementAvg = movementSeverities.length
        ? Math.round(movementSeverities.reduce((sum, val) => sum + val, 0) / movementSeverities.length)
        : null;
      const movementMax = movementSeverities.length
        ? Math.max(...movementSeverities)
        : null;

      return {
        counts: { entries: entries.length },
        percents: {
          hygiene_yes: yesNo('hygiene'),
          food_prep_yes: yesNo('food_prep'),
          cleanup_yes: yesNo('cleanup'),
        },
        totals: {
          vocational_minutes: sum('vocational_time'),
          community_minutes: sum('community_time'),
        },
        averages: {
          new_skill_score: promptAvg,
          movement_severity: movementAvg,
        },
        movement: {
          days: movementDays.size,
          max_severity: movementMax,
        }
      };
    }

    function buildMonthlySeries(entries){
      const byMonth = new Map();
      const byDay = new Map(); // YYYY-MM-DD -> { prompts: [] }
      for (const entry of entries){
        const ts = new Date(entry.timestamp || entry.created_at || entry.submitted_at || Date.now());
        if (Number.isNaN(ts.getTime())) continue;
        const monthKey = `${ts.getFullYear()}-${String(ts.getMonth() + 1).padStart(2, '0')}`;
        const bucket = byMonth.get(monthKey) || { h:0, f:0, c:0, prompts: [], total:0 };
        bucket.total += 1;
        if (entry.hygiene === true) bucket.h += 1;
        if (entry.food_prep === true) bucket.f += 1;
        if (entry.cleanup === true) bucket.c += 1;
        const prompt = getPromptValue(entry);
        if (Number.isFinite(prompt)) bucket.prompts.push(prompt);
        byMonth.set(monthKey, bucket);

        if (Number.isFinite(prompt)) {
          const dayKeyStr = `${monthKey}-${String(ts.getDate()).padStart(2, '0')}`;
          const dayBucket = byDay.get(dayKeyStr) || { prompts: [] };
          dayBucket.prompts.push(prompt);
          byDay.set(dayKeyStr, dayBucket);
        }
      }

      const monthly = Array.from(byMonth.entries())
        .sort(([a],[b])=>a.localeCompare(b))
        .map(([month,bucket])=>({
          x: month,
          hygiene_yes: bucket.h,
          food_prep_yes: bucket.f,
          cleanup_yes: bucket.c,
          avg_new_skill_score: bucket.prompts.length
            ? Math.round(bucket.prompts.reduce((sum,v)=>sum+v,0)/bucket.prompts.length)
            : null,
        }));

      const promptDaily = Array.from(byDay.entries())
        .sort(([a],[b])=>a.localeCompare(b))
        .map(([day,bucket])=>({
          x: day,
          avg_new_skill_score: bucket.prompts.length
            ? Math.round(bucket.prompts.reduce((sum,v)=>sum+v,0)/bucket.prompts.length)
            : null,
        }));

      return { monthly, promptDaily };
    }

    const INTERACTION_LABEL_OVERRIDES = [
      { match: /shared\s*space/i, label: 'Shared space respectfully' },
      { match: /greeting/i, label: 'Greeting' },
      { match: /small\s*talk/i, label: 'Small talk' },
      { match: /requested\s*help/i, label: 'Requested help' },
      { match: /asked\s*(a\s*)?question/i, label: 'Asked a question' },
      { match: /introduced/i, label: 'Introduced self/family' },
      { match: /compliment/i, label: 'Compliment' },
      { match: /offered\s*help/i, label: 'Offered help' },
      { match: /conflict/i, label: 'Conflict resolution' },
      { match: /aac/i, label: 'Used AAC appropriately' },
      { match: /eye\s*contact/i, label: 'Maintained eye contact' },
      { match: /other/i, label: 'Other' }
    ];

    function normalizeInteractionLabel(raw){
      const value = String(raw || '').trim();
      if (!value) return '';
      for (const rule of INTERACTION_LABEL_OVERRIDES) {
        if (rule.match.test(value)) return rule.label;
      }
      return value;
    }

    function buildCommunityInteractionCounts(entries){
      const counts = new Map();
      entries.forEach((entry) => {
        const payload = entry?.payload || {};
        const okRaw = payload.community_interaction_ok ?? entry?.community_interaction_ok;
        const ok = typeof okRaw === 'boolean'
          ? okRaw
          : /yes|true/i.test(String(okRaw || ''));
        const typeRaw = payload.interaction_type ?? entry?.interaction_type ?? '';
        const normalized = normalizeInteractionLabel(typeRaw);
        const hasType = !!normalized;
        if (!ok && !hasType) return;
        const label = hasType ? normalized : 'Unspecified';
        counts.set(label, (counts.get(label) || 0) + 1);
      });

      if (!counts.size) {
        return [
          { label: 'Shared space respectfully', count: 7 },
          { label: 'Greeting', count: 6 },
          { label: 'Small talk', count: 2 },
          { label: 'Requested help', count: 1 },
          { label: 'Other', count: 1 },
          { label: 'Unspecified', count: 1 },
          { label: 'Asked a question', count: 1 },
        ];
      }

      return Array.from(counts.entries())
        .map(([label, count]) => ({ label, count }))
        .sort((a, b) => (b.count - a.count) || a.label.localeCompare(b.label));
    }

    function buildActivityTypeCounts(entries){
      const home = new Map();
      const publicMap = new Map();
      const pushCount = (map, value) => {
        const label = normalizeInteractionLabel(value) || 'Unspecified';
        map.set(label, (map.get(label) || 0) + 1);
      };

      entries.forEach((entry) => {
        const payload = entry?.payload || {};
        const homeFlag = payload.home_activity_flag ?? entry?.home_activity_flag;
        const publicFlag = payload.public_activity_flag ?? entry?.public_activity_flag;
        const homeType = payload.home_activity_type ?? entry?.home_activity_type ?? '';
        const publicType = payload.public_activity_type ?? entry?.public_activity_type ?? '';
        const homeOk = /yes|true/i.test(String(homeFlag || '')) || !!homeType;
        const publicOk = /yes|true/i.test(String(publicFlag || '')) || !!publicType;
        if (homeOk) pushCount(home, homeType);
        if (publicOk) pushCount(publicMap, publicType);
      });

      const toTop = (map, fallback) => {
        const list = Array.from(map.entries())
          .map(([label, count]) => ({ label, count }))
          .sort((a, b) => (b.count - a.count) || a.label.localeCompare(b.label))
          .slice(0, 6);
        return list.length ? list : fallback;
      };

      return {
        home: toTop(home, [
          { label: 'Movie in living room', count: 4 },
          { label: 'Other', count: 2 },
          { label: 'Family game/movie night', count: 2 },
          { label: 'Meal in the common area', count: 1 }
        ]),
        public: toTop(publicMap, [
          { label: 'Shopping â€“ grocery/retail', count: 18 },
          { label: 'Went to recycling', count: 5 },
          { label: 'Walk / Stroll', count: 3 },
          { label: 'Other', count: 1 },
          { label: 'Restaurant/CafÃ©', count: 1 }
        ])
      };
    }

    function renderActivityTypeQuickLook(data){
      const homeList = document.getElementById('communityTypesHome');
      const publicList = document.getElementById('communityTypesPublic');
      if (!homeList || !publicList) return;
      const renderList = (el, items) => {
        el.innerHTML = '';
        if (!items?.length) {
          const li = document.createElement('li');
          li.className = 'community-types-item';
          li.innerHTML = '<span class="community-types-label">No data yet</span><span class="community-types-count">0</span>';
          el.appendChild(li);
          return;
        }
        items.forEach(item => {
          const li = document.createElement('li');
          li.className = 'community-types-item';
          const label = document.createElement('span');
          label.className = 'community-types-label';
          label.textContent = item.label;
          const count = document.createElement('span');
          count.className = 'community-types-count';
          count.textContent = String(item.count ?? 0);
          li.appendChild(label);
          li.appendChild(count);
          el.appendChild(li);
        });
      };
      renderList(homeList, data?.home || []);
      renderList(publicList, data?.public || []);
    }

    const CHART_RANGE_LABELS = {
      day: 'Day',
      week: 'Week',
      month: 'Month',
      year: 'Year',
      all: 'All time'
    };

    function getLatestEntryDate(entries){
      let latest = null;
      for (const entry of entries || []) {
        const dt = parseEntryDate(entry);
        if (!dt) continue;
        if (!latest || dt > latest) latest = dt;
      }
      return latest || new Date();
    }

    function getChartRangeWindow(rangeKey, entries){
      const end = new Date(getLatestEntryDate(entries));
      end.setHours(23,59,59,999);
      if (rangeKey === 'all') {
        return { start: null, end, label: 'All time' };
      }
      const start = new Date(end);
      if (rangeKey === 'day') {
        start.setHours(0,0,0,0);
      } else if (rangeKey === 'week') {
        start.setDate(end.getDate() - 6);
        start.setHours(0,0,0,0);
      } else if (rangeKey === 'month') {
        start.setDate(end.getDate() - 29);
        start.setHours(0,0,0,0);
      } else if (rangeKey === 'year') {
        start.setDate(end.getDate() - 364);
        start.setHours(0,0,0,0);
      }
      const label = `${formatLocalDate(start)}â€“${formatLocalDate(end)}`;
      return { start, end, label };
    }

    function truncateSeries(series, rangeKey){
      const limit = RANGE_LIMITS[rangeKey] ?? Infinity;
      if (!series || !series.length || !Number.isFinite(limit) || limit === Infinity) return series;
      return series.slice(-limit);
    }

    function filterEntriesByRange(entries, range){
      if (!range?.start) return entries.slice();
      return entries.filter(entry => {
        const dt = parseEntryDate(entry);
        if (!dt) return false;
        return dt >= range.start && dt <= range.end;
      });
    }

    function filterMoodEntriesByRange(entries, range){
      if (!range?.start) return entries.slice();
      return entries.filter(entry => entry.dateObj >= range.start && entry.dateObj <= range.end);
    }

    function updateChartRangeLabels(range, rangeKey){
      const label = range?.label || CHART_RANGE_LABELS[rangeKey] || 'All time';
      const display = rangeKey === 'all' ? 'All time' : `${CHART_RANGE_LABELS[rangeKey]} (${label})`;
      const displayEl = document.getElementById('chartRangeDisplay');
      if (displayEl) displayEl.textContent = `Showing: ${display}`;
      const healthLabel = document.getElementById('healthRangeLabel');
      if (healthLabel) healthLabel.textContent = `Range: ${display}`;
      const promptLabel = document.getElementById('promptRangeLabel');
      if (promptLabel) promptLabel.textContent = `Range: ${display}`;
      const communityLabel = document.getElementById('communityInteractionRangeLabel');
      if (communityLabel) communityLabel.textContent = `Range: ${display}`;
      const communityTypesLabel = document.getElementById('communityTypesRangeLabel');
      if (communityTypesLabel) communityTypesLabel.textContent = `Range: ${display}`;
      const engagementLabel = document.getElementById('engagementRangeLabel');
      if (engagementLabel) engagementLabel.textContent = `Range: ${display}`;
    }

    function updateMovementRangeLabel(range, rangeKey){
      const label = range?.label || CHART_RANGE_LABELS[rangeKey] || 'All time';
      const display = rangeKey === 'all' ? 'All time' : `${CHART_RANGE_LABELS[rangeKey]} (${label})`;
      const movementLabel = document.getElementById('movementRangeLabel');
      if (movementLabel) movementLabel.textContent = `Summary for ${display.toLowerCase()} range`;
      const movementDisplay = document.getElementById('movementRangeDisplay');
      if (movementDisplay) movementDisplay.textContent = `Showing: ${display}`;
    }

    function applyChartRange(){
      const rangeKey = document.getElementById('chartRangeSelect')?.value || 'month';
      const caregiverSource = (cgState.filtered && cgState.filtered.length) ? cgState.filtered : (cgState.entries || []);
      const range = getChartRangeWindow(rangeKey, caregiverSource);
      const filteredCaregiver = filterEntriesByRange(caregiverSource, range);
      const { monthly, promptDaily } = buildMonthlySeries(filteredCaregiver);
      drawHealthChart(truncateSeries(monthly, rangeKey));
      drawSkillChart(truncateSeries(promptDaily, rangeKey));
      drawCommunityInteractionChart(buildCommunityInteractionCounts(filteredCaregiver));
      renderActivityTypeQuickLook(buildActivityTypeCounts(filteredCaregiver));

      const moodSource = window.latestMoodEntries || [];
      const filteredMood = filterMoodEntriesByRange(moodSource, range);
      drawEngagementVsMood(filteredMood, filteredCaregiver);

      const movementSelect = document.getElementById('movementRangeSelect');
      if (movementSelect) movementSelect.value = rangeKey;
      applyMovementRange(rangeKey, caregiverSource);

      updateChartRangeLabels(range, rangeKey);
    }

    function applyMovementRange(rangeKey, caregiverSource = null){
      const source = caregiverSource
        || ((cgState.filtered && cgState.filtered.length) ? cgState.filtered : (cgState.entries || []));
      const range = getChartRangeWindow(rangeKey, source);
      const filteredCaregiver = filterEntriesByRange(source, range);
      const movementInsights = filteredCaregiver.length
        ? buildMovementInsights(filteredCaregiver)
        : buildDemoMovementInsights();
      drawMovementSeverityChart(movementInsights.severitySeries);
      drawMovementTypeChart(movementInsights.typeCounts);
      drawMovementBodyChart(movementInsights.bodyCounts);
      drawMovementTriggerChart(movementInsights.triggerCounts);
      const summaryDays = document.getElementById('movementDaysVal');
      const summaryAvg = document.getElementById('movementAvgVal');
      const summaryMax = document.getElementById('movementMaxVal');
      const summaryType = document.getElementById('movementTypeVal');
      const summaryTime = document.getElementById('movementTimeVal');
      if (summaryDays) summaryDays.textContent = movementInsights.daysWithSymptoms ?? 0;
      if (summaryAvg) summaryAvg.textContent = movementInsights.avgSeverity ?? 'â€”';
      if (summaryMax) summaryMax.textContent = movementInsights.maxSeverity ?? 'â€”';
      if (summaryType) {
        const label = MOVEMENT_TYPE_LABELS[movementInsights.mostCommonType] || movementInsights.mostCommonType || 'â€”';
        summaryType.textContent = label;
      }
      if (summaryTime) {
        const label = MOVEMENT_TIME_LABELS[movementInsights.mostCommonTime] || movementInsights.mostCommonTime || 'â€”';
        summaryTime.textContent = label;
      }
      updateMovementRangeLabel(range, rangeKey);
    }

    /* =================== Caregiver table helpers =================== */
    const cgInputs = {
      start: $('#cgStart'),
      end: $('#cgEnd'),
      apply: $('#cgApply'),
      caregiver: $('#cgCaregiver'),
      filterBanner: document.getElementById('cgFilterBanner'),
      filterLabel: document.getElementById('cgFilterLabel'),
      notesToggle: document.getElementById('cgNotesToggle'),
      count: $('#cgCount'),
      pdf: $('#cgPdf'),
      sharePdf: $('#cgSharePdf'),
      csv: $('#cgCsv'),
      tbody: document.getElementById('cgTbody')
    };
    const CAREGIVER_FILE_BUCKET = 'caregiver-files'; // Change if caregiver attachments live in a different bucket.
    const editUi = {
      overlay: document.getElementById('cgEditOverlay'),
      form: document.getElementById('cgEditForm'),
      status: document.getElementById('cgEditStatus'),
      date: document.getElementById('cgEditDate'),
      time: document.getElementById('cgEditTime'),
      sleepTime: document.getElementById('cgEditSleepTime'),
      bm: document.getElementById('cgEditBm'),
      anomaly: document.getElementById('cgEditAnomaly'),
      hygiene: document.getElementById('cgEditHygiene'),
      foodPrep: document.getElementById('cgEditFoodPrep'),
      cleanup: document.getElementById('cgEditCleanup'),
      vocational: document.getElementById('cgEditVoc'),
      community: document.getElementById('cgEditCommunity'),
      skill: document.getElementById('cgEditSkill'),
      notes: document.getElementById('cgEditNotes'),
      file: document.getElementById('cgEditFile'),
      fileNote: document.getElementById('cgEditFileNote'),
      idInput: document.getElementById('cgEditId'),
      cancel: document.getElementById('cgEditCancel'),
      save: document.getElementById('cgEditSave')
    };
    const noteUi = {
      overlay: document.getElementById('cgNoteOverlay'),
      title: document.getElementById('cgNoteTitle'),
      timestamp: document.getElementById('cgNoteTimestamp'),
      caregiver: document.getElementById('cgNoteCaregiver'),
      body: document.getElementById('cgNoteBody'),
      file: document.getElementById('cgNoteFile'),
      edit: document.getElementById('cgNoteEdit'),
      close: document.getElementById('cgNoteClose'),
      closeFooter: document.getElementById('cgNoteCloseFooter')
    };
    const editState = { currentId: null, record: null };

    const quickLookUi = {
      panel: $('#cgQuickLook'),
      content: $('#cgQuickLookContent'),
      empty: $('#cgQuickLookEmpty'),
      toggle: $('#cgQuickLookToggle'),
      close: $('#cgQuickLookClose'),
      printSheet: $('#cgQuickLookPrint')
    };

    const focusUi = {
      panel: document.getElementById('reportFocusPanel'),
      summary: document.getElementById('reportFocusSummary'),
      planner: document.getElementById('focusPlannerStats'),
      plannerPanel: document.getElementById('plannerChartSection'),
      plannerChartWrap: document.getElementById('plannerChartWrap'),
      plannerRow: document.getElementById('plannerRow'),
      goals: document.getElementById('reportFocusGoals'),
      chartEl: document.getElementById('focusGoalChart')
    };
    let currentFocusPlan = null;
    let focusChart = null;
    let plannerChart = null;
    let plannerTrackerStats = null;
    let plannerTrackerDays = [];
    let plannerChartNotes = [];
    const buildDemoFocus = () => ({
      weekStart: '2026-01-26',
      focusArea: 'Communication',
      customTitle: 'Ask for help at the store',
      whyMatters: 'Build confidence in requesting assistance in public settings.',
      nextSteps: 'Use visual prompt card, then fade to verbal prompt.',
      goals: [
        { id:'g1', title:'Ask for help', promptGoal: 2, steps:['Practice greeting','Use help phrase','Thank staff'], notes:'Short, calm prompts' },
        { id:'g2', title:'Wait in line calmly', promptGoal: 3, steps:['Stand in line','Hands to self','Deep breaths'], notes:'Use timer' },
        { id:'g3', title:'Choose an item', promptGoal: 1, steps:['Pick item','Check price','Place in basket'], notes:'Reduce prompts' }
      ],
      days: [
        { day:'Mon', practiced:true, promptLevel:3, note:'Used visual card' },
        { day:'Tue', practiced:false, promptLevel:null, note:'' },
        { day:'Wed', practiced:true, promptLevel:2, note:'Less prompting' },
        { day:'Thu', practiced:true, promptLevel:2, note:'Short wait' },
        { day:'Fri', practiced:true, promptLevel:1, note:'Independent ask' },
        { day:'Sat', practiced:false, promptLevel:null, note:'' },
        { day:'Sun', practiced:false, promptLevel:null, note:'' }
      ]
    });
    const WEEKDAY_LABELS = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];
    const PROMPT_LABELS = {
      '0': 'Independent',
      '1': '1â€“2 prompts',
      '2': 'Periodic prompts',
      '3': 'Frequent prompts',
      '4': 'Dependent'
    };

    const CAREGIVER_ID_PREFIX = 'id:';
    const CAREGIVER_NAME_PREFIX = 'name:';

    const FRIENDLY_CAREGIVER_LABELS = {
      'caregiver.a@starapp.demo': 'Caregiver A',
      'caregiver.b@starapp.demo': 'Caregiver B',
      'caregiver.c@starapp.demo': 'Caregiver C'
    };
    const friendlyNameFromEmail = (email) => {
      if (!email) return null;
      const normalized = String(email).trim().toLowerCase();
      return FRIENDLY_CAREGIVER_LABELS[normalized] || null;
    };

    const cgState = {
      entries: [],
      filtered: [],
      caregiverFilter: 'all', // Default is always all caregivers on fresh load.
      entryById: new Map(),
      focusStats: new Map(),
      rangeInitialized: false
    };

    const buildDemoCaregiverEntries = (baseDate = new Date()) => {
      const entries = [];
      const makeDate = (offsetDays, hour, minute) => {
        const dt = new Date(baseDate);
        dt.setDate(dt.getDate() - offsetDays);
        dt.setHours(hour, minute, 0, 0);
        return dt.toISOString();
      };
      const demoNotes = [
        'Morning routine was smooth. Needed a few prompts to start breakfast. Talked about the schedule for the day.',
        'Went to the grocery store. Asked a staff member for help finding cereal. Stayed calm in line.',
        'Short walk outside. Practiced greeting a neighbor. Used AAC to say â€œhelloâ€.',
        'Family movie night. Shared space respectfully and helped set up snacks.',
        'Visited the library. Asked a question at the desk and checked out books.',
        'Recycling drop-off and park stroll. Needed 2 prompts to stay on task.',
        'Community center class. Participated well with minimal prompting.'
      ];
      const interactionTypes = [
        'Shared space respectfully',
        'Requested help',
        'Used AAC appropriately',
        'Small talk',
        'Asked a question',
        'Greeting',
        'Introduced self/family'
      ];
      const homeTypes = [
        'Movie in living room',
        'Family game/movie night',
        'Meal with immediate family',
        'Walk / neighborhood stroll',
        'Other'
      ];
      const publicTypes = [
        'Shopping â€“ grocery/retail',
        'Library',
        'Park/Playground',
        'Went to recycling',
        'Restaurant/CafÃ©',
        'Other'
      ];

      for (let i = 0; i < 7; i += 1) {
        const ts = makeDate(i * 2, 9 + i, 15);
        const id = `demo-cg-${i + 1}`;
        const caregiverName = i % 2 === 0 ? 'Caregiver A' : 'Caregiver B';
        const prompt = [2, 1, 3, 1, 2, 2, 1][i];
        const hygiene = i % 3 !== 0;
        const food = i % 2 === 0;
        const cleanup = i % 4 !== 0;
        const voc = [30, 45, 20, 60, 15, 40, 25][i];
        const com = [40, 55, 25, 30, 50, 35, 60][i];
        const movementPresent = i % 3 === 0;

        entries.push({
          id,
          user_id: 'demo-user',
          caregiver_name: caregiverName,
          created_at: ts,
          submitted_at: ts,
          hygiene,
          food_prep: food,
          cleanup,
          vocational_time: voc,
          community_time: com,
          new_skill_score: prompt,
          movement_present: movementPresent,
          movement_severity: movementPresent ? (i % 5) : null,
          movement_main_type: movementPresent ? 'hands_shaking' : null,
          movement_times: movementPresent ? ['AM'] : [],
          payload: {
            caregiver_name: caregiverName,
            caregiver_notes: demoNotes[i],
            community_notes: demoNotes[i],
            home_activity_flag: 'Yes',
            home_activity_type: homeTypes[i % homeTypes.length],
            public_activity_flag: 'Yes',
            public_activity_type: publicTypes[i % publicTypes.length],
            community_interaction_ok: 'Yes',
            interaction_type: interactionTypes[i % interactionTypes.length]
          }
        });
      }

      return entries;
    };

    const caregiverIdFromEntry = (entry = {}) => {
      const payload = entry.payload || {};
      const candidates = [
        entry.user_id,
        entry.caregiver_id,
        payload.user_id,
        payload.caregiver_id,
        payload.owner_id
      ];
      for (const value of candidates) {
        if (value === null || value === undefined) continue;
        const str = String(value).trim();
        if (str) return str;
      }
      return '';
    };

    const emailFromEntry = (entry = {}) => {
      const payload = entry.payload || {};
      const candidates = [
        entry.caregiver_email,
        payload.caregiver_email,
        payload.caregiver_mail,
        entry.email,
        payload.email,
        entry.user_email,
        payload.user_email,
        entry.owner_email,
        payload.owner_email
      ];
      for (const value of candidates) {
        if (typeof value !== 'string') continue;
        const trimmed = value.trim();
        if (trimmed) return trimmed.toLowerCase();
      }
      return '';
    };

    const caregiverNameFromEntry = (entry = {}) => {
      const payload = entry.payload || {};
      const candidates = [
        entry.caregiver_name,
        payload.caregiver_name,
        payload.caregiver,
        payload.submitted_by,
        payload.entered_by
      ];
      for (const value of candidates) {
        if (typeof value !== 'string') continue;
        const trimmed = value.trim();
        if (trimmed) return trimmed;
      }
      const friendly = friendlyNameFromEmail(emailFromEntry(entry));
      if (friendly) return friendly;
      const email = emailFromEntry(entry);
      return email || '';
    };

    const matchesCaregiverFilter = (entry, filterValue) => {
      if (!filterValue || filterValue === 'all') return true;
      if (filterValue.startsWith(CAREGIVER_ID_PREFIX)) {
        const id = caregiverIdFromEntry(entry);
        return id && id === filterValue.slice(CAREGIVER_ID_PREFIX.length);
      }
      if (filterValue.startsWith(CAREGIVER_NAME_PREFIX)) {
        const name = caregiverNameFromEntry(entry).toLowerCase();
        return name && name === filterValue.slice(CAREGIVER_NAME_PREFIX.length);
      }
      return true;
    };

    function parseEntryDate(entry = {}) {
      const payload = entry.payload || {};
      const candidates = [
        entry.timestamp,
        entry.created_at,
        entry.createdAt,
        entry.date,
        entry.date_recorded,
        payload.timestamp,
        payload.created_at,
        payload.date
      ];
      for (const value of candidates) {
        const date = parseCaregiverDate(value);
        if (date) return date;
      }
      return null;
    }

    function extractEntryNotes(entry = {}) {
      const payload = entry.payload || {};
      const candidates = [
        entry.notes,
        entry.caregiver_notes,
        entry.daily_notes,
        entry.day_notes,
        payload.notes,
        payload.caregiver_notes,
        payload.physical_notes,
        payload.behavior_notes,
        payload.community_notes,
        payload.daily_living_notes,
        payload.note
      ];
      const parts = [];
      const seen = new Set();
      const normalize = (value) => String(value).replace(/\s+/g, ' ').trim();
      const pushBlock = (block) => {
        const trimmed = String(block || '').trim();
        if (!trimmed) return;
        const key = normalize(trimmed);
        if (!key || seen.has(key)) return;
        seen.add(key);
        parts.push(trimmed);
      };
      const splitBlocks = (text) =>
        String(text)
          .split(/\n\s*\n/g)
          .map((chunk) => chunk.trim())
          .filter(Boolean);

      for (const candidate of candidates) {
        if (Array.isArray(candidate)) {
          candidate.forEach(item => {
            if (typeof item === 'string') {
              splitBlocks(item).forEach(pushBlock);
            }
          });
          continue;
        }
        if (typeof candidate === 'string') {
          splitBlocks(candidate).forEach(pushBlock);
        }
      }
      return parts.join('\n\n');
    }

    function pickNumber(...values) {
      for (const value of values) {
        if (value === null || value === undefined || value === '') continue;
        const num = Number(value);
        if (Number.isFinite(num)) return num;
      }
      return null;
    }

    function getPromptValue(entry = {}) {
      const payload = entry.payload || {};
      return pickNumber(
        entry.new_skill_score,
        entry.prompt_level,
        entry.prompting_level,
        payload.new_skill_score,
        payload.prompt_level,
        payload.prompting_level
      );
    }

    function isAffirmative(value) {
      if (value === true) return true;
      if (value === false) return false;
      if (typeof value === 'number') return value > 0;
      if (typeof value === 'string') {
        const normalized = value.trim().toLowerCase();
        if (!normalized) return false;
        return ['yes','y','true','1','done','complete','completed'].includes(normalized);
      }
      return false;
    }

    const isCalendarOnlyEntry = (entry = {}) =>
      entry?.payload?.calendar_only === true;

    function formatQuickLookDate(dateStr) {
      if (!dateStr) return 'â€”';
      const parts = dateStr.split('-').map(Number);
      const date = new Date(parts[0] || 0, (parts[1] || 1) - 1, parts[2] || 1);
      if (Number.isNaN(date.getTime())) return dateStr;
      return date.toLocaleDateString(undefined, { weekday:'short', month:'short', day:'numeric' });
    }

    function truncateText(text, max = 160) {
      if (!text) return '';
      const normalized = String(text).trim();
      if (normalized.length <= max) return normalized;
      return `${normalized.slice(0, max - 1).trim()}â€¦`;
    }

    function caregiverFilterLabel(value) {
      if (!value || value === 'all') return 'All caregivers';
      const option = cgInputs.caregiver?.querySelector(`option[value="${CSS.escape(value)}"]`);
      if (option?.textContent) return option.textContent;
      if (value.startsWith(CAREGIVER_ID_PREFIX)) return `Caregiver ${value.slice(CAREGIVER_ID_PREFIX.length, CAREGIVER_ID_PREFIX.length + 6)}â€¦`;
      if (value.startsWith(CAREGIVER_NAME_PREFIX)) return value.slice(CAREGIVER_NAME_PREFIX.length);
      return value;
    }

    function updateCaregiverFilterBanner() {
      if (!cgInputs.filterBanner || !cgInputs.filterLabel) return;
      const hasFilter = cgState.caregiverFilter && cgState.caregiverFilter !== 'all';
      cgInputs.filterLabel.textContent = caregiverFilterLabel(cgState.caregiverFilter);
      cgInputs.filterBanner.classList.toggle('is-hidden', !hasFilter);
    }

    function clearCaregiverFilters() {
      // Reset filters to defaults so nothing is hidden by accident.
      if (cgInputs.caregiver) cgInputs.caregiver.value = 'all';
      cgState.caregiverFilter = 'all';
      updateDateInputs(cgState.entries);
      updateCaregiverFilterBanner();
      applyCaregiverFilters();
    }

    const NOTE_STOPWORDS = new Set([
      'the','and','for','with','this','that','they','them','was','were','are','been','from','into','over','under',
      'when','then','than','there','here','just','today','yesterday','tomorrow','about','after','before','again',
      'because','could','would','should','their','there','some','more','less','very','also','able','still','really',
      'maybe','while','where','what','which','who','whom','your','yours','our','ours','his','her','hers','him','she',
      'he','its','had','has','have','did','does','doing','done','not','yes','no','but','out','off','got','get','gets'
    ]);

    function extractTopNoteThemeSentence(notes) {
      const text = notes.join(' ').replace(/\s+/g, ' ').trim();
      if (!text) return 'None';
      const sentences = text
        .split(/(?<=[.!?])\s+/)
        .map(sentence => sentence.trim())
        .filter(Boolean);
      if (!sentences.length) return 'None';
      const seen = new Set();
      const uniqueSentences = [];
      sentences.forEach(sentence => {
        const key = sentence.toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim();
        if (!key || seen.has(key)) return;
        seen.add(key);
        uniqueSentences.push(sentence);
      });
      const wordCounts = new Map();
      uniqueSentences.forEach(sentence => {
        sentence.toLowerCase().split(/[^a-z0-9]+/).forEach(word => {
          if (!word || word.length < 4) return;
          if (NOTE_STOPWORDS.has(word)) return;
          wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
        });
      });
      const scored = uniqueSentences.map((sentence, index) => {
        const score = sentence.toLowerCase().split(/[^a-z0-9]+/)
          .reduce((sum, word) => sum + (wordCounts.get(word) || 0), 0);
        return { sentence, index, score };
      });
      const top = scored.sort((a, b) => b.score - a.score || a.index - b.index)[0];
      return top?.sentence || uniqueSentences[0] || 'None';
    }

    function buildNoteSynopsis(notes, sentenceCount = 3) {
      const text = notes.join(' ').replace(/\s+/g, ' ').trim();
      if (!text) return 'No summary available.';
      const sentences = text
        .split(/(?<=[.!?])\s+/)
        .map(sentence => sentence.trim())
        .filter(Boolean);
      if (!sentences.length) return 'No summary available.';
      const seen = new Set();
      const uniqueSentences = [];
      sentences.forEach(sentence => {
        const key = sentence.toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim();
        if (!key || seen.has(key)) return;
        seen.add(key);
        uniqueSentences.push(sentence);
      });

      const wordCounts = new Map();
      uniqueSentences.forEach(sentence => {
        sentence.toLowerCase().split(/[^a-z0-9]+/).forEach(word => {
          if (!word || word.length < 4) return;
          if (NOTE_STOPWORDS.has(word)) return;
          wordCounts.set(word, (wordCounts.get(word) || 0) + 1);
        });
      });

      const scored = uniqueSentences.map((sentence, index) => {
        const score = sentence.toLowerCase().split(/[^a-z0-9]+/)
          .reduce((sum, word) => sum + (wordCounts.get(word) || 0), 0);
        return { sentence, index, score };
      });

      const top = scored
        .sort((a, b) => b.score - a.score || a.index - b.index)
        .slice(0, Math.min(sentenceCount, scored.length))
        .sort((a, b) => a.index - b.index)
        .map(item => item.sentence);

      return top.join(' ');
    }

    function weekStartDate(date) {
      const d = new Date(date.getFullYear(), date.getMonth(), date.getDate());
      const offset = (d.getDay() + 6) % 7; // Monday = 0
      d.setDate(d.getDate() - offset);
      return d;
    }

    function monthKey(date) {
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    }

    function formatMonthLabel(key) {
      const [year, month] = key.split('-').map(Number);
      const dt = new Date(year, (month || 1) - 1, 1);
      return dt.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    }

    function summarizeBuckets(entries, bucketKeyFn) {
      const buckets = new Map();
      entries.forEach(entry => {
        const date = normalizeEntryDate(entry);
        if (!date) return;
        const key = bucketKeyFn(date);
        if (!key) return;
        if (!buckets.has(key)) {
          buckets.set(key, {
            key,
            count: 0,
            hygieneYes: 0,
            foodYes: 0,
            cleanupYes: 0,
            promptSum: 0,
            promptCount: 0,
            vocTotal: 0,
            comTotal: 0,
            notes: []
          });
        }
        const bucket = buckets.get(key);
        bucket.count += 1;
        if (isAffirmative(entry.hygiene ?? entry.payload?.hygiene)) bucket.hygieneYes += 1;
        if (isAffirmative(entry.food_prep ?? entry.payload?.food_prep)) bucket.foodYes += 1;
        if (isAffirmative(entry.cleanup ?? entry.payload?.cleanup)) bucket.cleanupYes += 1;
        const promptVal = getPromptValue(entry);
        if (promptVal !== null) {
          bucket.promptSum += promptVal;
          bucket.promptCount += 1;
        }
        const voc = pickNumber(entry.vocational_time, entry.vocational_minutes, entry.payload?.vocational_time, entry.payload?.vocational_minutes);
        if (voc !== null) bucket.vocTotal += voc;
        const com = pickNumber(entry.community_time, entry.community_minutes, entry.payload?.community_time, entry.payload?.community_minutes);
        if (com !== null) bucket.comTotal += com;
        const note = extractEntryNotes(entry);
        if (note) bucket.notes.push(note);
      });
      return [...buckets.values()].sort((a, b) => a.key.localeCompare(b.key));
    }

    function renderCaregiverPdfSummaries(entries) {
      const weeklyEl = document.getElementById('cgWeeklySummary');
      const monthlyEl = document.getElementById('cgMonthlySummary');
      if (!weeklyEl || !monthlyEl) return;
      weeklyEl.innerHTML = '';
      monthlyEl.innerHTML = '';
      if (!entries.length) {
        weeklyEl.innerHTML = '<div class="cg-summary-card">No caregiver check-ins in this range.</div>';
        monthlyEl.innerHTML = '';
        return;
      }

      const weekly = summarizeBuckets(entries, (date) => {
        const start = weekStartDate(date);
        return `${start.getFullYear()}-${String(start.getMonth() + 1).padStart(2, '0')}-${String(start.getDate()).padStart(2, '0')}`;
      });
      const monthly = summarizeBuckets(entries, (date) => monthKey(date));

      const renderCard = (bucket, label) => {
        const pct = (count) => bucket.count ? `${Math.round((count / bucket.count) * 100)}%` : 'â€”';
        const avgPrompt = bucket.promptCount ? Math.round(bucket.promptSum / bucket.promptCount) : 'â€”';
        const synopsis = buildNoteSynopsis(bucket.notes, 3);
        const themeSentence = extractTopNoteThemeSentence(bucket.notes);
        const card = document.createElement('div');
        card.className = 'cg-summary-card';
        card.innerHTML = `
          <h4>${label}</h4>
          <div class="cg-summary-row"><span class="label">Check-ins</span><span>${bucket.count}</span></div>
          <div class="cg-summary-row"><span class="label">Hygiene % Yes</span><span>${pct(bucket.hygieneYes)}</span></div>
          <div class="cg-summary-row"><span class="label">Food % Yes</span><span>${pct(bucket.foodYes)}</span></div>
          <div class="cg-summary-row"><span class="label">Clean-up % Yes</span><span>${pct(bucket.cleanupYes)}</span></div>
          <div class="cg-summary-row"><span class="label">Avg prompt level</span><span>${avgPrompt}</span></div>
          <div class="cg-summary-row"><span class="label">Vocational minutes</span><span>${Math.round(bucket.vocTotal)}</span></div>
          <div class="cg-summary-row"><span class="label">Community minutes</span><span>${Math.round(bucket.comTotal)}</span></div>
          <div class="cg-summary-row"><span class="label">Note summary</span><span>${synopsis}</span></div>
          <div class="cg-summary-row"><span class="label">Top note theme</span><span>${themeSentence}</span></div>
        `;
        return card;
      };

      weekly.forEach(bucket => {
        const start = new Date(bucket.key);
        const end = new Date(start);
        end.setDate(end.getDate() + 6);
        const label = `Week of ${start.toLocaleDateString(undefined, { month:'short', day:'numeric' })}â€“${end.toLocaleDateString(undefined, { month:'short', day:'numeric' })}`;
        weeklyEl.appendChild(renderCard(bucket, label));
      });
      monthly.forEach(bucket => {
        monthlyEl.appendChild(renderCard(bucket, formatMonthLabel(bucket.key)));
      });
    }

    function collectRecentCaregiverDays(entries, limit = 5) {
      const buckets = new Map();
      for (const entry of entries) {
        if (isCalendarOnlyEntry(entry)) continue;
        const ts = parseEntryDate(entry);
        if (!ts) continue;
        const key = localDateKey(ts);
        if (!key) continue;
        let bucket = buckets.get(key);
        if (!bucket) {
          bucket = {
            date: key,
            entryCount: 0,
            hygieneYes: 0,
            foodYes: 0,
            cleanupYes: 0,
            vocMinutes: 0,
            comMinutes: 0,
            promptTotal: 0,
            promptCount: 0,
            caregivers: new Set(),
            latestNote: '',
            latestTs: 0,
            entries: []
          };
          buckets.set(key, bucket);
        }
        const payload = entry.payload || {};
        bucket.entryCount += 1;
        if (isAffirmative(entry.hygiene ?? payload.hygiene)) bucket.hygieneYes += 1;
        if (isAffirmative(entry.food_prep ?? payload.food_prep)) bucket.foodYes += 1;
        if (isAffirmative(entry.cleanup ?? payload.cleanup)) bucket.cleanupYes += 1;

        const voc = pickNumber(entry.vocational_time, entry.vocational_minutes, payload.vocational_time, payload.vocational_minutes);
        if (voc !== null) bucket.vocMinutes += voc;

        const com = pickNumber(entry.community_time, entry.community_minutes, payload.community_time, payload.community_minutes);
        if (com !== null) bucket.comMinutes += com;

        const promptVal = getPromptValue(entry);
        if (promptVal !== null) {
          bucket.promptTotal += promptVal;
          bucket.promptCount += 1;
        }

        const caregiverName = caregiverNameFromEntry(entry);
        if (caregiverName) bucket.caregivers.add(caregiverName);

        const note = extractEntryNotes(entry);
        const stamp = ts.getTime();
        if (note && stamp >= bucket.latestTs) {
          bucket.latestNote = note;
          bucket.latestTs = stamp;
        }

        bucket.entries.push({
          id: entry.id || `${key}-${bucket.entryCount}`,
          timestamp: ts.toLocaleString(undefined, {
            weekday: 'short',
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: '2-digit'
          }),
          iso: ts.toISOString(),
          caregiver: caregiverNameFromEntry(entry) || 'Unknown caregiver',
          notes: note || '',
          rawNotes: note || '',
          prompt: getPromptValue(entry),
          hygiene: entry.hygiene ?? payload.hygiene,
          food: entry.food_prep ?? payload.food_prep,
          cleanup: entry.cleanup ?? payload.cleanup
        });
      }

      return [...buckets.values()]
        .sort((a, b) => b.date.localeCompare(a.date))
        .slice(0, limit)
        .map(bucket => ({
          date: bucket.date,
          entryCount: bucket.entryCount,
          hygieneYes: bucket.hygieneYes,
          foodYes: bucket.foodYes,
          cleanupYes: bucket.cleanupYes,
          vocMinutes: Math.round(bucket.vocMinutes),
          comMinutes: Math.round(bucket.comMinutes),
          avgPrompt: bucket.promptCount ? Math.round(bucket.promptTotal / bucket.promptCount) : null,
          caregivers: Array.from(bucket.caregivers),
          latestNote: bucket.latestNote,
          entries: bucket.entries.sort((a, b) => (a.iso || '').localeCompare(b.iso || ''))
        }));
    }

    function buildQuickLookMetric(label, value) {
      const wrap = document.createElement('div');
      wrap.className = 'quick-look-metric';
      const labelEl = document.createElement('span');
      labelEl.className = 'metric-label';
      labelEl.textContent = label;
      const valueEl = document.createElement('span');
      valueEl.className = 'metric-value';
      valueEl.textContent = value;
      wrap.append(labelEl, valueEl);
      return wrap;
    }

    function buildQuickLookCard(day) {
      const card = document.createElement('article');
      card.className = 'quick-look-card';
      card.id = `quick-look-card-${day.date}`;

      const header = document.createElement('div');
      header.className = 'quick-look-header';
      const dateEl = document.createElement('div');
      dateEl.className = 'quick-look-date';
      dateEl.textContent = formatQuickLookDate(day.date);
      const printBtn = document.createElement('button');
      printBtn.type = 'button';
      printBtn.className = 'quick-look-print no-export';
      printBtn.textContent = 'ğŸ–¨ Print day';
      printBtn.addEventListener('click', () => printQuickLookDay(card, day));
      header.append(dateEl, printBtn);
      card.appendChild(header);

      const countEl = document.createElement('div');
      countEl.className = 'quick-look-count';
      countEl.textContent = `${day.entryCount} check-in${day.entryCount === 1 ? '' : 's'}`;
      card.appendChild(countEl);

      const metrics = document.createElement('div');
      metrics.className = 'quick-look-metrics';
      metrics.append(
        buildQuickLookMetric('Hygiene', `${day.hygieneYes} yes`),
        buildQuickLookMetric('Food', `${day.foodYes} yes`),
        buildQuickLookMetric('Clean-up', `${day.cleanupYes} yes`),
        buildQuickLookMetric('Voc mins', `${day.vocMinutes}`),
        buildQuickLookMetric('Comm mins', `${day.comMinutes}`),
        buildQuickLookMetric('Prompt avg', day.avgPrompt ?? 'â€”')
      );
      card.appendChild(metrics);

      const caregivers = document.createElement('p');
      caregivers.className = 'quick-look-caregivers';
      caregivers.textContent = day.caregivers.length
        ? `Caregivers: ${day.caregivers.join(', ')}`
        : 'Caregivers: â€”';
      card.appendChild(caregivers);

      if (day.latestNote) {
        const note = document.createElement('p');
        note.className = 'quick-look-note';
        note.textContent = `Last note: ${truncateText(day.latestNote)}`;
        card.appendChild(note);
      }

      const notesBtn = document.createElement('button');
      notesBtn.type = 'button';
      notesBtn.className = 'quick-look-notes-btn no-export';
      notesBtn.textContent = 'Show notes';
      card.appendChild(notesBtn);

      const notesWrap = document.createElement('div');
      notesWrap.className = 'quick-look-notes is-hidden';
      const entries = (Array.isArray(day.entries) ? day.entries : []).filter(entry => (entry.notes || '').trim().length);
      if (!entries.length) {
        const empty = document.createElement('p');
        empty.className = 'muted';
        empty.textContent = 'No notes for this day.';
        notesWrap.appendChild(empty);
      } else {
        const notesList = document.createElement('ul');
        notesList.className = 'quick-look-notes-list';
        entries.forEach(entry => {
          const row = document.createElement('li');
          row.className = 'quick-look-note-row';
          const meta = document.createElement('div');
          meta.className = 'quick-look-note-meta';
          meta.textContent = `${entry.timestamp} â€¢ ${entry.caregiver}`;
          const text = document.createElement('div');
          text.className = 'quick-look-note-text';
          text.textContent = entry.notes.trim();
          row.append(meta, text);
          notesList.appendChild(row);
        });
        notesWrap.appendChild(notesList);
      }
      card.appendChild(notesWrap);

      notesBtn.addEventListener('click', () => {
        const currentlyHidden = notesWrap.classList.contains('is-hidden');
        notesWrap.classList.toggle('is-hidden', !currentlyHidden);
        notesBtn.textContent = currentlyHidden ? 'Hide notes' : 'Show notes';
      });

      return card;
    }

    async function printQuickLookDay(card, day) {
      const entries = (Array.isArray(day.entries) ? day.entries : []).filter(entry => (entry.notes || '').trim().length);
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ unit:'pt', format:'a4' });
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const margin = 40;
      const bodyWidth = pageW - margin * 2;
      const metrics = [
        ['Hygiene yes', `${day.hygieneYes}`],
        ['Food yes', `${day.foodYes}`],
        ['Clean-up yes', `${day.cleanupYes}`],
        ['Voc mins', `${day.vocMinutes}`],
        ['Comm mins', `${day.comMinutes}`],
        ['Prompt avg', day.avgPrompt ?? 'â€”']
      ];

      let y = margin;
      const ensureSpace = (needed = 0) => {
        if (y + needed > pageH - margin) {
          pdf.addPage();
          y = margin;
        }
      };

      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(18);
      pdf.text(`Quick Look â€” ${formatQuickLookDate(day.date)}`, margin, y);
      y += 20;
      pdf.setFontSize(12);
      const caregiversLine = day.caregivers.length ? day.caregivers.join(', ') : 'â€”';
      pdf.text(`Check-ins: ${day.entryCount}    Caregivers: ${caregiversLine}`, margin, y);
      y += 18;

      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(11);
      const colWidth = bodyWidth / 3;
      metrics.forEach((metric, idx) => {
        const col = idx % 3;
        const row = Math.floor(idx / 3);
        const x = margin + col * colWidth;
        const line = `${metric[0]}: ${metric[1]}`;
        pdf.text(line, x, y + row * 14);
      });
      y += Math.ceil(metrics.length / 3) * 14 + 6;
      pdf.setDrawColor(220);
      pdf.line(margin, y, pageW - margin, y);
      y += 16;

      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(13);
      pdf.text('Notes', margin, y);
      y += 14;
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(11);

      if (!entries.length) {
        pdf.text('No notes recorded for this day.', margin, y);
      } else {
        for (const entry of entries) {
          const meta = `${entry.timestamp} â€¢ ${entry.caregiver}`;
          const body = entry.notes.trim();
          ensureSpace(28);
          pdf.setFont('helvetica', 'bold');
          pdf.text(meta, margin, y);
          y += 14;
          pdf.setFont('helvetica', 'normal');
          const lines = pdf.splitTextToSize(body, bodyWidth);
          lines.forEach(line => {
            ensureSpace(14);
            pdf.text(line, margin, y);
            y += 14;
          });
          y += 10;
        }
      }

      pdf.save(`Caregiver_${day.date}_Quick_Look.pdf`);
    }

    function renderQuickLook(sourceEntries) {
      if (!quickLookUi.content) return;
      const entries = Array.isArray(sourceEntries)
        ? sourceEntries
        : (Array.isArray(cgState.filtered) ? cgState.filtered : cgState.entries);
      const days = collectRecentCaregiverDays(entries || [], 5);
      quickLookUi.content.innerHTML = '';
      if (!days.length) {
        quickLookUi.content.classList.add('is-hidden');
        quickLookUi.empty?.classList.remove('is-hidden');
        return;
      }
      quickLookUi.content.classList.remove('is-hidden');
      quickLookUi.empty?.classList.add('is-hidden');
      days.forEach(day => {
        quickLookUi.content.appendChild(buildQuickLookCard(day));
      });
    }

    function normalizePlannerDays(days = []){
      const normalized = [];
      for (let i = 0; i < 7; i++){
        const raw = days[i] || {};
        const promptVal = Number(raw.promptLevel ?? raw.prompt_level);
        normalized.push({
          label: WEEKDAY_LABELS[i] || `Day ${i + 1}`,
          practiced: !!raw.practiced,
          prompt: Number.isFinite(promptVal) ? promptVal : null,
          note: raw.note || raw.notes || '',
          raw
        });
      }
      return normalized;
    }

    function summarizePlannerDays(days = []){
      if (!Array.isArray(days) || !days.length) return null;
      const practiced = days.filter(day => day && (day.practiced || day.completed));
      if (!practiced.length) return null;
      const promptVals = practiced
        .map(day => Number(day.promptLevel ?? day.prompt_level))
        .filter(Number.isFinite);
      const avgPrompt = promptVals.length
        ? Number((promptVals.reduce((sum, val) => sum + val, 0) / promptVals.length).toFixed(1))
        : null;
      const last = practiced[practiced.length - 1] || {};
      return {
        count: practiced.length,
        avgPrompt,
        lastNote: last.note || last.notes || '',
        lastDay: last.day || last.date || null,
      };
    }

    function renderPlannerStats(stats, days){
      plannerTrackerStats = stats || null;
      plannerTrackerDays = Array.isArray(days) ? days : [];
      if (!focusUi.planner) {
        renderPlannerChart(plannerTrackerDays);
        return;
      }
      if (!stats?.count){
        focusUi.planner.classList.add('is-hidden');
        focusUi.planner.textContent = '';
        renderPlannerChart(plannerTrackerDays);
        return;
      }
      const pieces = [
        `${stats.count} practice day${stats.count === 1 ? '' : 's'}`,
        `Avg prompt level: ${stats.avgPrompt ?? 'â€”'}`,
        `Last note: ${stats.lastNote || 'â€”'}`
      ];
      focusUi.planner.textContent = pieces.join(' â€¢ ');
      focusUi.planner.classList.remove('is-hidden');
      renderPlannerChart(plannerTrackerDays);
    }

    function updateFocusPdfSummary(focus, localFallback){
      const titleEl = document.getElementById('focusPdfTitle');
      const bodyEl = document.getElementById('focusPdfBody');
      const statsEl = document.getElementById('focusPdfStats');
      if (!titleEl || !bodyEl || !statsEl) return;
      if (!focus){
        titleEl.textContent = 'Weekly Focus';
        bodyEl.textContent = 'No weekly focus set.';
        statsEl.textContent = '';
        return;
      }
      const start = focus.weekStart ? new Date(focus.weekStart) : null;
      const end = start ? new Date(start) : null;
      if (end) end.setDate(end.getDate() + 6);
      const range = start && end ? `${start.toLocaleDateString()} â€“ ${end.toLocaleDateString()}` : '';
      const title = focus.customTitle || 'Weekly focus';
      const area = focus.focusArea ? `(${focus.focusArea})` : '';
      const offlineTag = localFallback ? ' (Offline copy)' : '';
      const why = focus.whyMatters ? `${focus.whyMatters}` : '';
      const next = focus.nextSteps ? `Next: ${focus.nextSteps}` : '';
      titleEl.textContent = `Weekly Focus ${offlineTag}`.trim();
      bodyEl.textContent = [title, area, range, why, next].filter(Boolean).join(' â€¢ ');
      if (plannerTrackerStats?.count) {
        const parts = [
          `${plannerTrackerStats.count} practice day${plannerTrackerStats.count === 1 ? '' : 's'}`,
          `Avg prompt level: ${plannerTrackerStats.avgPrompt ?? 'â€”'}`,
          `Last note: ${plannerTrackerStats.lastNote || 'â€”'}`
        ];
        statsEl.textContent = parts.join(' â€¢ ');
      } else {
        statsEl.textContent = 'No practice data logged.';
      }
    }

    async function loadFocusPanel(){
      if (!focusUi.summary) return;
      try{
        let focus = null;
        let localFallback = false;
        try {
          const result = await loadFocusForCurrentUser();
          focus = result?.focus || null;
        } catch (err) {
          console.warn('focus panel load failed (shared)', err);
        }
        if (!focus) {
          focus = readLocalFocusDraft();
          localFallback = !!focus;
        }
        if (!focus){
          // DEMO fallback
          focus = buildDemoFocus();
          localFallback = true;
        }
        currentFocusPlan = focus;
        const start = focus.weekStart ? new Date(focus.weekStart) : null;
        const end = start ? new Date(start) : null;
        if (end) end.setDate(end.getDate() + 6);
        const range = start && end ? `${start.toLocaleDateString()} â€“ ${end.toLocaleDateString()}` : '';
        const title = focus.customTitle || 'Weekly focus';
        const area = focus.focusArea ? `(${focus.focusArea})` : '';
        const next = focus.nextSteps ? `<br><small>Next: ${focus.nextSteps}</small>` : '';
        const offlineTag = localFallback ? '<br><small>(Showing draft saved on this device)</small>' : '';
        focusUi.summary.innerHTML = `<strong>${title}</strong> ${area}${range ? `<br><small>${range}</small>` : ''}${focus.whyMatters ? `<br>${focus.whyMatters}` : ''}${next}${offlineTag}`;
        renderPlannerStats(summarizePlannerDays(focus.days), focus.days || []);
        renderFocusGoalList(focus.goals || []);
        renderFocusGoalChart(focus.goals || []);
        updateFocusPdfSummary(focus, localFallback);
      } catch (error){
        const fallback = readLocalFocusDraft();
        if (fallback) {
          const next = fallback.nextSteps ? `<br><small>Next: ${fallback.nextSteps}</small>` : '';
          focusUi.summary.innerHTML = `<strong>${fallback.customTitle || 'Weekly focus'}</strong>${fallback.whyMatters ? `<br>${fallback.whyMatters}` : ''}${next}<br><small>(Offline copy)</small>`;
          renderPlannerStats(summarizePlannerDays(fallback.days), fallback.days || []);
          renderFocusGoalList(fallback.goals || []);
          renderFocusGoalChart(fallback.goals || []);
          currentFocusPlan = fallback;
          updateFocusPdfSummary(fallback, true);
        } else {
          focusUi.summary.textContent = 'Unable to load weekly focus.';
          currentFocusPlan = null;
          renderPlannerStats(null, []);
          updateFocusPdfSummary(null, false);
        }
        console.warn('focus panel load failed', error);
      }
    }

    function renderFocusGoalList(goals){
      if (!focusUi.goals) return;
      const stats = cgState.focusStats || new Map();
      focusUi.goals.innerHTML = '';
      if (!Array.isArray(goals) || !goals.length){
        const li = document.createElement('li');
        li.textContent = 'Add weekly goals to the Focus page.';
        focusUi.goals.appendChild(li);
        return;
      }
      goals.forEach(goal => {
        const stat = stats.get(goal.id);
        const practiced = stat?.count || 0;
        const avgPromptVal = stat?.promptCount ? (stat.promptSum / stat.promptCount).toFixed(1) : null;
        const avgPromptLabel = avgPromptVal != null
          ? `${avgPromptVal} avg (${PROMPT_LABELS[String(Math.round(avgPromptVal))] || 'prompt level'})`
          : 'No prompt data yet';
        const titleRaw = (goal.title || '').trim();
        const notesRaw = (goal.notes || '').trim();
        const hasPlaceholderTitle = !titleRaw || titleRaw.toLowerCase() === 'goal title';
        const displayTitle = hasPlaceholderTitle ? 'Notes' : titleRaw;
        const li = document.createElement('li');
        li.innerHTML = `<strong>${displayTitle}</strong>${notesRaw ? `<span>${notesRaw}</span>` : ''}<br><small>${practiced} practices Â· ${avgPromptLabel}</small>`;
        focusUi.goals.appendChild(li);
      });
    }

    function buildFocusStats(entries = []){
      const stats = new Map();
      entries.forEach(entry => {
        const logs = Array.isArray(entry.focus_goal_logs)
          ? entry.focus_goal_logs
          : Array.isArray(entry.payload?.focus_goal_logs)
            ? entry.payload.focus_goal_logs
            : [];
        logs.forEach(log => {
          const id = log.goal_id || log.goal_title || 'goal';
          if (!stats.has(id)) {
            stats.set(id, { id, title: log.goal_title || id, count: 0, promptSum: 0, promptCount: 0 });
          }
          const stat = stats.get(id);
          if (log.practiced) stat.count += 1;
          const num = Number(log.prompt_level);
          if (Number.isFinite(num)) {
            stat.promptSum += num;
            stat.promptCount += 1;
          }
        });
      });
      return stats;
    }

    function renderPlannerChart(days = []){
      if (!focusUi.plannerChartWrap || !focusUi.plannerRow) return;
      const normalized = normalizePlannerDays(days);
      // DEMO fallback: fixed practiced days for the post-it
      const practicedSet = new Set([0, 1, 3, 4]);
      focusUi.plannerPanel?.classList.remove('is-hidden');
      focusUi.plannerChartWrap.classList.remove('is-hidden');
      focusUi.plannerRow.innerHTML = '';
      // Build 6 practice dots with dates inside
      const totalDays = 6;
      const dateNumbers = [3, 6, 10, 14, 20, 27];
      for (let i = 0; i < totalDays; i++) {
        const cell = document.createElement('div');
        cell.className = 'practice-cell';
        const dot = document.createElement('div');
        const practiced = practicedSet.has(i);
        dot.className = `practice-dot ${practiced ? 'on' : 'off'}`;
        dot.textContent = dateNumbers[i];
        cell.appendChild(dot);
        focusUi.plannerRow.appendChild(cell);
      }
    }

    function renderFocusGoalChart(goals){
      if (!focusUi.chartEl) return;
      const stats = cgState.focusStats || new Map();
      const plannerCount = plannerTrackerStats?.count || 0;
      const hasGoals = Array.isArray(goals) && goals.length > 0;
      const counts = hasGoals ? goals.map(g => stats.get(g.id)?.count || 0) : [];
      const hasLoggedCounts = counts.some(count => count > 0);

      if (!hasGoals && !plannerCount){
        focusUi.chartEl.classList.add('is-hidden');
        focusChart?.destroy();
        focusChart = null;
        return;
      }

      if (!hasLoggedCounts && !plannerCount){
        focusUi.chartEl.classList.add('is-hidden');
        focusChart?.destroy();
        focusChart = null;
        return;
      }

      let chartLabels = [];
      let chartData = [];
      let chartLabel = '# practices logged';
      let chartColor = '#fcd34d';
      let borderColor = '#f97316';

      if (hasLoggedCounts){
        chartLabels = goals.map(g => g.title || 'Goal');
        chartData = counts;
      } else if (plannerCount){
        chartLabels = ['Practice days'];
        chartData = [plannerCount];
        chartLabel = 'Planner tracker';
        chartColor = '#fde047';
        borderColor = '#ca8a04';
      }

      focusUi.chartEl.classList.remove('is-hidden');
      focusChart?.destroy();
      focusChart = new Chart(focusUi.chartEl, {
        type: 'bar',
        data: {
          labels: chartLabels,
          datasets: [{
            label: chartLabel,
            data: chartData,
            backgroundColor: chartColor,
            borderColor
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: { beginAtZero: true, ticks: { precision:0 } }
          }
        }
      });
    }

    function toggleQuickLook(force) {
      if (!quickLookUi.panel) return;
      const isActive = document.body.classList.contains('quick-look-mode');
      const shouldShow = typeof force === 'boolean' ? force : !isActive;
      document.body.classList.toggle('quick-look-mode', shouldShow);
      quickLookUi.panel.classList.toggle('is-hidden', !shouldShow);
      quickLookUi.toggle?.setAttribute('aria-expanded', shouldShow ? 'true' : 'false');
      if (quickLookUi.toggle) {
        quickLookUi.toggle.textContent = shouldShow ? 'â†© Exit Quick Look' : 'âš¡ Quick Look';
      }
      if (shouldShow) {
        const source = Array.isArray(cgState.filtered) ? cgState.filtered : cgState.entries;
        renderQuickLook(source);
      }
    }

    function populateCaregiverOptions(entries){
      const select = cgInputs.caregiver;
      if (!select) return;
      select.innerHTML = '';

      const addOption = (value, label) => {
        if (!value) return;
        const option = document.createElement('option');
        option.value = value;
        option.textContent = label || value;
        select.appendChild(option);
      };

      addOption('all', 'All caregivers');

      const session = getSessionFromStorage();
      const selfId = session?.user?.id ? String(session.user.id) : '';
      const selfEmail = session?.user?.email?.toLowerCase() || '';
      const friendlySelf = friendlyNameFromEmail(selfEmail);
      const selfLabel = friendlySelf ||
        session?.user?.user_metadata?.full_name ||
        session?.user?.user_metadata?.name ||
        (selfEmail ? selfEmail.split('@')[0] : '') ||
        (selfId ? `Me (${selfId.slice(0,6)}â€¦)` : '');
      if (selfId) {
        addOption(CAREGIVER_ID_PREFIX + selfId, selfLabel ? `${selfLabel} (Me)` : 'My check-ins');
      }

      const optionMap = new Map();
      for (const entry of entries) {
        const id = caregiverIdFromEntry(entry);
        const name = caregiverNameFromEntry(entry);
        const email = emailFromEntry(entry);
        const friendly = friendlyNameFromEmail(email);
        const fallbackName = friendly || name || (email ? email.split('@')[0] : '');
        if (id) {
          const key = CAREGIVER_ID_PREFIX + id;
          if (!optionMap.has(key)) {
            optionMap.set(key, fallbackName || `Caregiver ${id.slice(0,6)}â€¦`);
          }
        } else if (fallbackName) {
          const key = CAREGIVER_NAME_PREFIX + fallbackName.toLowerCase();
          if (!optionMap.has(key)) {
            optionMap.set(key, fallbackName);
          }
        }
      }

      const existingValues = new Set(Array.from(select.options).map(opt => opt.value));
      for (const [value, label] of optionMap.entries()) {
        if (existingValues.has(value)) continue;
        addOption(value, label || 'Unnamed caregiver');
        existingValues.add(value);
      }

      // Filters should never persist silently; default view is always "All caregivers."
      select.value = 'all';
      cgState.caregiverFilter = 'all';
      updateCaregiverFilterBanner();
    }

    const fallbackFormat = (e) => {
      const yn = (val) => val === true ? 'Yes' : val === false ? 'No' : 'â€”';
      const ts = e.timestamp || e.created_at || e.submitted_at || Date.now();
      return {
        id: e.id || e.uuid || null,
        dateTime: formatLocalDateTimeLabel(ts),
        hygiene: yn(e.hygiene ?? e.had_bm),
        food_prep: yn(e.food_prep),
        cleanup: yn(e.cleanup),
        vocational_time: e.vocational_time ?? 'â€”',
        community_time: e.community_time ?? 'â€”',
        new_skill_score: e.new_skill_score ?? 'â€”',
        notes: e.caregiver_notes || e.notes || '',
        file_url: e.file_url || ''
      };
    };

    const normalizeDateOnly = (value) => {
      if (!value) return null;
      const trimmed = String(value).trim();
      if (!trimmed) return null;

      let year, month, day;

      if (trimmed.includes('-')) {
        const parts = trimmed.split('-');
        if (parts.length !== 3) return null;
        year = Number(parts[0]);
        month = Number(parts[1]) - 1;
        day = Number(parts[2]);
      } else if (trimmed.includes('/')) {
        const parts = trimmed.split('/');
        if (parts.length !== 3) return null;
        month = Number(parts[0]) - 1;
        day = Number(parts[1]);
        year = Number(parts[2]);
      } else {
        return null;
      }

      if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) return null;
      const date = new Date(year, month, day);
      return Number.isFinite(date.getTime()) ? date : null;
    };

    function normalizeEntryDate(entry){
      const raw = entry.timestamp || entry.created_at || entry.submitted_at || entry.date;
      if (!raw) return null;
      const dt = parseCaregiverDate(raw);
      if (!dt) return null;
      return new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
    }

    function updateDateInputs(entries){
      if (!cgInputs.start || !cgInputs.end) return;
      if (cgState.rangeInitialized) return;
      const today = new Date();
      const start = new Date(today);
      start.setDate(start.getDate() - 30);
      cgInputs.start.value = formatDateInputValue(start);
      cgInputs.end.value = formatDateInputValue(today);
      cgState.rangeInitialized = true;
    }

    function renderCaregiverCheckins(entries){
      const body = cgInputs.tbody;
      if (!body) return;
      body.innerHTML = '';

      if (!entries.length) {
        body.innerHTML = `<tr><td colspan="10">No caregiver check-ins found for the selected range.</td></tr>`;
        return;
      }

      entries.forEach((entry, index) => {
        const row = formatEntryForList ? formatEntryForList(entry) : fallbackFormat(entry);
        const tr = document.createElement('tr');
        const caregiverLabel = caregiverNameFromEntry(entry) || 'â€”';

        const cells = [
          row.dateTime || 'â€”',
          caregiverLabel,
          row.hygiene ?? 'â€”',
          row.food_prep ?? 'â€”',
          row.cleanup ?? 'â€”',
          row.vocational_time ?? 'â€”',
          row.community_time ?? 'â€”',
          row.new_skill_score ?? 'â€”'
        ];

        cells.forEach(value => {
          const td = document.createElement('td');
          td.textContent = value === '' ? 'â€”' : value;
          tr.appendChild(td);
        });

        const notesTd = document.createElement('td');
        notesTd.className = 'cg-notes-cell';
        const notes = (extractEntryNotes(entry) || row.notes || '').trim();
        const preview = document.createElement('div');
        preview.className = 'cg-note-preview';
        preview.textContent = notes ? truncateText(notes, 140) : 'â€”';
        notesTd.appendChild(preview);
        if (notes) {
          const viewBtn = document.createElement('button');
          viewBtn.type = 'button';
          viewBtn.className = 'cg-note-btn';
          viewBtn.textContent = 'View full note';
          if (entry.id || row.id) {
            viewBtn.dataset.checkinId = entry.id || row.id;
          } else {
            viewBtn.dataset.rowIndex = String(index);
          }
          notesTd.appendChild(viewBtn);
        }
        const fullNotes = document.createElement('div');
        fullNotes.className = 'cg-note-full';
        fullNotes.textContent = notes || 'â€”';
        notesTd.appendChild(fullNotes);
        tr.appendChild(notesTd);
        const actionTd = document.createElement('td');
        // Each Edit button carries the Supabase row id so the delegation handler can load it in the modal.
        const checkinId = entry.id || row.id;
        if (checkinId) {
          const editBtn = document.createElement('button');
          editBtn.type = 'button';
          editBtn.className = 'cg-edit-btn';
          editBtn.textContent = 'Edit';
          editBtn.dataset.checkinId = checkinId;
          actionTd.appendChild(editBtn);
        } else {
          actionTd.textContent = 'â€”';
        }
        tr.appendChild(actionTd);
        body.appendChild(tr);
      });
    }

    const boolToFieldValue = (value) => (value === true ? 'true' : value === false ? 'false' : '');
    const fieldValueToBool = (value) => (value === 'true' ? true : value === 'false' ? false : null);
    const numberFromField = (value) => {
      if (value === '' || value === null || value === undefined) return null;
      const num = Number(value);
      return Number.isFinite(num) ? num : null;
    };
    const parseLooseBoolean = (value) => {
      if (value === true || value === false) return value;
      if (typeof value === 'number') {
        if (value === 1) return true;
        if (value === 0) return false;
      }
      if (typeof value === 'string') {
        const norm = value.trim().toLowerCase();
        if (!norm) return null;
        if (['true','t','yes','y','1'].includes(norm)) return true;
        if (['false','f','no','n','0'].includes(norm)) return false;
      }
      return null;
    };
    const parseRecordTimestamp = (record) => {
      if (!record) return null;
      return parseCaregiverDate(
        record.submitted_at ||
        record.created_at ||
        record.timestamp ||
        (record.date ? `${record.date}` : null)
      );
    };
    const buildTimestampFromInputs = (record, dateStr, timeStr) => {
      if (!dateStr && !timeStr) return null;
      const base = parseRecordTimestamp(record);
      const day = dateStr || (base ? formatDateInputValue(base) : '');
      if (!day) return null;
      let time = timeStr || (base ? formatTimeInputValue(base) : '');
      if (!time) time = '00:00';
      const dt = parseCaregiverDate(`${day}T${time}`);
      return dt ? dt.toISOString() : null;
    };
    const setEditStatus = (message) => {
      if (editUi.status) editUi.status.textContent = message || '';
    };

    async function fetchCaregiverCheckin(checkinId){
      if (!checkinId) throw new Error('Missing check-in id.');
      const id = String(checkinId);
      if (id.startsWith('demo-')) {
        const demoRecord = cgState.entryById.get(id);
        if (demoRecord) return demoRecord;
        throw new Error('Demo check-in not found.');
      }
      const path = `caregiver_checkins?select=*&id=eq.${encodeURIComponent(checkinId)}`;
      const rows = await rest(path);
      const record = Array.isArray(rows) ? rows[0] : rows;
      if (!record) throw new Error('Check-in not found.');
      return record;
    }

    function populateEditForm(checkinData){
      if (!checkinData || !editUi.form) return;
      const payload = checkinData.payload || {};
      const timestamp = parseRecordTimestamp(checkinData);
      editUi.idInput.value = checkinData.id || '';
      if (editUi.date) {
        const existingDate = checkinData.date || (timestamp ? formatDateInputValue(timestamp) : '');
        editUi.date.value = existingDate || '';
      }
      if (editUi.time) {
        editUi.time.value = formatTimeInputValue(timestamp) || '';
      }
      if (editUi.sleepTime) {
        const sleepTime =
          payload.sleep_onset_time ||
          payload.sleep_time ||
          payload.fell_asleep_time ||
          payload.asleep_time ||
          '';
        editUi.sleepTime.value = sleepTime || '';
      }
      if (editUi.bm) {
        const bmVal = parseLooseBoolean(
          checkinData.had_bm ??
          payload.had_bm ??
          payload.bm_today
        );
        editUi.bm.value = boolToFieldValue(bmVal);
      }
      if (editUi.anomaly) {
        const anomalyVal = parseLooseBoolean(
          checkinData.anomaly_flag ??
          payload.anomaly_flag ??
          payload.anomaly
        );
        editUi.anomaly.value = boolToFieldValue(anomalyVal);
      }
      editUi.hygiene.value = boolToFieldValue(parseLooseBoolean(
        checkinData.hygiene ??
        payload.hygiene ??
        payload.hygiene_flag
      ));
      editUi.foodPrep.value = boolToFieldValue(parseLooseBoolean(
        checkinData.food_prep ??
        payload.food_prep ??
        payload.prepared_food
      ));
      editUi.cleanup.value = boolToFieldValue(parseLooseBoolean(
        checkinData.cleanup ??
        payload.cleanup ??
        payload.cleanup_flag
      ));
      editUi.vocational.value = checkinData.vocational_time ?? '';
      editUi.community.value = checkinData.community_time ?? '';
      editUi.skill.value = checkinData.new_skill_score ?? '';
      editUi.notes.value = checkinData.caregiver_notes || '';
      if (editUi.file) editUi.file.value = '';
      if (editUi.fileNote) {
        editUi.fileNote.textContent = checkinData.file_url
          ? 'Existing file uploaded. Uploading a new file will replace it.'
          : 'No file uploaded for this entry.';
      }
    }

    function closeEditModal(){
      if (!editUi.overlay) return;
      editState.currentId = null;
      editState.record = null;
      editUi.form?.reset();
      if (editUi.fileNote) editUi.fileNote.textContent = 'No file uploaded for this entry.';
      setEditStatus('Select a row to load its Supabase data.');
      if (editUi.save) {
        editUi.save.disabled = false;
        editUi.save.textContent = 'Save Changes';
      }
      editUi.overlay.classList.add('is-hidden');
    }

    function closeNoteDrawer(){
      if (!noteUi.overlay) return;
      noteUi.overlay.classList.add('is-hidden');
      if (noteUi.edit) noteUi.edit.dataset.checkinId = '';
    }

    function openNoteDrawer(entry){
      if (!noteUi.overlay || !entry) return;
      const ts = parseRecordTimestamp(entry) || parseEntryDate(entry) || new Date();
      const caregiverLabel = caregiverNameFromEntry(entry) || 'Unknown caregiver';
      const notes = extractEntryNotes(entry) || 'â€”';
      // Full notes live in a dedicated drawer so table rows stay compact.
      if (noteUi.timestamp) noteUi.timestamp.textContent = formatLocalDateTimeLabel(ts);
      if (noteUi.caregiver) noteUi.caregiver.textContent = caregiverLabel;
      if (noteUi.body) noteUi.body.textContent = notes;
      if (noteUi.file) {
        const fileUrl = entry.file_url || entry?.payload?.file_url || '';
        noteUi.file.href = fileUrl || '#';
        noteUi.file.classList.toggle('is-hidden', !fileUrl);
      }
      if (noteUi.edit) noteUi.edit.dataset.checkinId = entry.id || '';
      noteUi.overlay.classList.remove('is-hidden');
    }

    // openEditModal fetches a single caregiver_checkins row (select().eq('id').single()) and fills the modal form.
    async function openEditModal(checkinId){
      if (!editUi.overlay) return;
      editState.currentId = checkinId;
      editState.record = null;
      if (editUi.save) {
        editUi.save.disabled = true;
        editUi.save.textContent = 'Save Changes';
      }
      setEditStatus('Loading check-inâ€¦');
      editUi.overlay.classList.remove('is-hidden');
      try {
        const record = await fetchCaregiverCheckin(checkinId);
        editState.record = record;
        populateEditForm(record);
        const when = record.created_at || record.submitted_at || record.timestamp;
        setEditStatus(`Editing entry from ${formatLocalDateTimeLabel(when || new Date())}`);
        if (editUi.save) editUi.save.disabled = false;
      } catch (error) {
        console.error('Edit load failed', error);
        alert('Could not load that check-in. Please refresh and try again.');
        closeEditModal();
      }
    }

    // Uploads a replacement attachment to Supabase Storage and returns the public URL for file_url.
    async function uploadCaregiverFile(file){
      if (!file) return editState.record?.file_url || null;
      const session = getSessionFromStorage();
      const token = session?.access_token;
      const userId = session?.user?.id;
      if (!token || !userId) throw new Error('Sign in again to upload files.');
      const now = new Date();
      const folder = `${userId}/${now.getFullYear()}/${String(now.getMonth() + 1).padStart(2, '0')}`;
      const safeName = (file.name || 'attachment').replace(/\s+/g, '_').replace(/[^a-zA-Z0-9._-]/g, '');
      const unique = typeof crypto?.randomUUID === 'function' ? crypto.randomUUID() : Date.now().toString(36);
      const path = `${folder}/${unique}_${safeName}`;
      const endpoint = `${SUPABASE_URL}/storage/v1/object/${CAREGIVER_FILE_BUCKET}/${path}`;
      const res = await fetch(endpoint, {
        method: 'POST',
        headers: {
          apikey: SUPABASE_ANON_KEY,
          Authorization: `Bearer ${token}`,
          'x-upsert': 'true',
          'Content-Type': file.type || 'application/octet-stream'
        },
        body: file
      });
      if (!res.ok) {
        const message = await res.text();
        throw new Error(message || 'Upload failed.');
      }
      return `${SUPABASE_URL}/storage/v1/object/public/${CAREGIVER_FILE_BUCKET}/${path}`;
    }

    // handleUpdateCheckin mirrors supabase.from('caregiver_checkins').update(...).eq('id', currentId) then refreshes the view.
    async function handleUpdateCheckin(event){
      event.preventDefault();
      if (!editState.currentId) return;
      const originalLabel = editUi.save ? editUi.save.textContent : 'Save Changes';
      if (editUi.save) {
        editUi.save.disabled = true;
        editUi.save.textContent = 'Savingâ€¦';
      }
      setEditStatus('Saving changesâ€¦');

      try {
        const dateValue = editUi.date?.value || '';
        const timeValue = editUi.time?.value || '';
        const timestampIso = buildTimestampFromInputs(editState.record, dateValue, timeValue);
        const hadBmValue = fieldValueToBool(editUi.bm?.value || '');
        const anomalyValue = fieldValueToBool(editUi.anomaly?.value || '');
        const updates = {
          hygiene: fieldValueToBool(editUi.hygiene.value),
          food_prep: fieldValueToBool(editUi.foodPrep.value),
          cleanup: fieldValueToBool(editUi.cleanup.value),
          vocational_time: numberFromField(editUi.vocational.value),
          community_time: numberFromField(editUi.community.value),
          new_skill_score: numberFromField(editUi.skill.value),
          caregiver_notes: editUi.notes.value.trim() || null,
          date: dateValue || null,
          had_bm: hadBmValue
        };
        if (timestampIso) {
          updates.submitted_at = timestampIso;
        }
        const sleepTimeValue = editUi.sleepTime?.value || '';
        const payloadClone = { ...(editState.record?.payload || {}) };
        if (dateValue) {
          payloadClone.entry_date = dateValue;
        } else {
          delete payloadClone.entry_date;
        }
        if (sleepTimeValue) {
          payloadClone.sleep_onset_time = sleepTimeValue;
        } else {
          delete payloadClone.sleep_onset_time;
        }
        if (hadBmValue === true) {
          payloadClone.had_bm = 'yes';
          payloadClone.bm_today = 'yes';
        } else if (hadBmValue === false) {
          payloadClone.had_bm = 'no';
          payloadClone.bm_today = 'no';
        } else {
          delete payloadClone.had_bm;
          delete payloadClone.bm_today;
        }
        if (anomalyValue === true) {
          payloadClone.anomaly_flag = true;
          payloadClone.anomaly = 'yes';
        } else if (anomalyValue === false) {
          payloadClone.anomaly_flag = false;
          payloadClone.anomaly = 'no';
        } else {
          delete payloadClone.anomaly_flag;
          delete payloadClone.anomaly;
        }

        const file = editUi.file?.files?.[0] || null;
        let fileUrl = editState.record?.file_url || payloadClone.file_url || null;
        if (file) {
          fileUrl = await uploadCaregiverFile(file);
        }
        if (fileUrl) {
          payloadClone.file_url = fileUrl;
        } else {
          delete payloadClone.file_url;
        }
        updates.payload = payloadClone;

        if (String(editState.currentId).startsWith('demo-')) {
          const demoEntry = cgState.entryById.get(String(editState.currentId));
          if (demoEntry) {
            demoEntry.hygiene = updates.hygiene;
            demoEntry.food_prep = updates.food_prep;
            demoEntry.cleanup = updates.cleanup;
            demoEntry.vocational_time = updates.vocational_time;
            demoEntry.community_time = updates.community_time;
            demoEntry.new_skill_score = updates.new_skill_score;
            demoEntry.caregiver_notes = updates.caregiver_notes;
            demoEntry.had_bm = updates.had_bm;
            if (updates.submitted_at) {
              demoEntry.submitted_at = updates.submitted_at;
              demoEntry.created_at = updates.submitted_at;
            }
            demoEntry.payload = updates.payload || demoEntry.payload || {};
            cgState.entryById.set(String(editState.currentId), demoEntry);
          }
          applyCaregiverFilters();
          closeEditModal();
        } else {
          const path = `caregiver_checkins?id=eq.${encodeURIComponent(editState.currentId)}`;
          await rest(path, {
            method: 'PATCH',
            headers: { Prefer: 'return=representation' },
            body: JSON.stringify(updates)
          });

          await loadCaregiverData();
          closeEditModal();
        }
      } catch (error) {
        console.error('Caregiver update failed', error);
        alert(error?.message || 'Could not update this check-in.');
        setEditStatus('Update failed. Please try again.');
      } finally {
        if (editUi.save) {
          editUi.save.disabled = false;
          editUi.save.textContent = originalLabel;
        }
      }
    }

    function updateCgSummary(filtered, total){
      if (!cgInputs.count) return;
      if (!total) {
        cgInputs.count.textContent = 'No caregiver check-ins yet.';
        return;
      }
      if (!filtered.length) {
        cgInputs.count.textContent = 'No caregiver check-ins match this range.';
        return;
      }
      const plural = filtered.length === 1 ? 'check-in' : 'check-ins';
      const base = `${filtered.length} ${plural}`;
      cgInputs.count.textContent = (filtered.length === total)
        ? base
        : `${base} (of ${total} total)`;
    }

    function filterCaregiverEntries(entries){
      const start = normalizeDateOnly(cgInputs.start?.value || '');
      const end   = normalizeDateOnly(cgInputs.end?.value || '');
      const caregiverFilter = cgState.caregiverFilter || 'all';
      return entries.filter(entry => {
        if (!matchesCaregiverFilter(entry, caregiverFilter)) return false;
        const date = normalizeEntryDate(entry);
        if (!date) return false;
        if (start && date < start) return false;
        if (end && date > end) return false;
        return true;
      });
    }

    function applyCaregiverFilters(){
      const entries = cgState.entries.slice();
      if (cgInputs.caregiver) {
        cgState.caregiverFilter = cgInputs.caregiver.value || 'all';
      }
      updateCaregiverFilterBanner();
      if (!entries.length) {
        renderCaregiverCheckins([]);
        updateCgSummary([], 0);
        renderQuickLook([]);
        return;
      }
      const filtered = filterCaregiverEntries(entries);
      cgState.filtered = filtered;
      renderCaregiverCheckins(filtered);
      updateCgSummary(filtered, entries.length);
      renderQuickLook(filtered);
      renderCaregiverPdfSummaries(filtered);
      applyChartRange();
    }

    window.applyCaregiverFilters = applyCaregiverFilters;

    function exportCaregiverCsv(){
      const source = (cgState.filtered && cgState.filtered.length) ? cgState.filtered : cgState.entries;
      if (!source.length) {
        alert('No caregiver check-ins to export yet.');
        return;
      }
      const rows = source.map(entry => ({
        entry,
        row: formatEntryForList ? formatEntryForList(entry) : fallbackFormat(entry)
      }));
      const headers = ['Timestamp','Caregiver','Hygiene','Food','Clean-up','Voc (min)','Comm (min)','Prompt','Notes'];
      const csvLines = [
        headers.join(',')
      ];
      rows.forEach(({ entry, row }) => {
        const caregiverLabel = caregiverNameFromEntry(entry) || '';
        const notesValue = extractEntryNotes(entry) || row.notes || '';
        const values = [
          row.dateTime || '',
          caregiverLabel,
          row.hygiene || '',
          row.food_prep || '',
          row.cleanup || '',
          row.vocational_time || '',
          row.community_time || '',
          row.new_skill_score || '',
          notesValue.replace(/\r?\n|\r/g, ' ')
        ].map(value => {
          const str = String(value ?? '');
          return /[",\n]/.test(str) ? `"${str.replace(/"/g, '""')}"` : str;
        });
        csvLines.push(values.join(','));
      });
      const blob = new Blob([csvLines.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `caregiver-checkins-${new Date().toISOString().slice(0,10)}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // PDF exports should include full notes even when the table is compact.
    function setCaregiverNotesExportMode(enabled){
      document.body.classList.toggle('cg-export-notes', enabled);
    }
    window.setCaregiverNotesExportMode = setCaregiverNotesExportMode;

    async function exportCaregiverPdf(){
      if (!cgState.entries.length) {
        alert('No caregiver data to export yet.');
        return;
      }
      setCaregiverNotesExportMode(true);
      try {
        await exportElement('#cg-panel', 'Caregiver_Checkins.pdf');
      } finally {
        setCaregiverNotesExportMode(false);
      }
    }

    /* =================== KPIs & caregiver-derived charts =================== */
    const kpi = {
      entries: $('#kpi-entries'), hygiene: $('#kpi-hygiene'), food: $('#kpi-food'),
      cleanup: $('#kpi-cleanup'), voc: $('#kpi-voc'), com: $('#kpi-com'), prompt: $('#kpi-prompt'),
      moveDays: $('#kpi-move-days'), moveAvg: $('#kpi-move-avg'), moveMax: $('#kpi-move-max')
    };

    function renderKPIs(summary){
      kpi.entries.textContent = summary.counts.entries ?? 0;
      kpi.hygiene.textContent = (summary.percents.hygiene_yes ?? 0) + '%';
      kpi.food.textContent    = (summary.percents.food_prep_yes ?? 0) + '%';
      kpi.cleanup.textContent = (summary.percents.cleanup_yes ?? 0) + '%';
      kpi.voc.textContent     = summary.totals.vocational_minutes ?? 0;
      kpi.com.textContent     = summary.totals.community_minutes ?? 0;
      kpi.prompt.textContent  = summary.averages.new_skill_score ?? 'â€”';
      if (kpi.moveDays) kpi.moveDays.textContent = summary.movement?.days ?? 0;
      if (kpi.moveAvg) kpi.moveAvg.textContent = summary.averages?.movement_severity ?? 'â€”';
      if (kpi.moveMax) kpi.moveMax.textContent = summary.movement?.max_severity ?? 'â€”';

      const inline = {
        entries: $('#kpi-entries-inline'),
        hygiene: $('#kpi-hygiene-inline'),
        food: $('#kpi-food-inline'),
        cleanup: $('#kpi-cleanup-inline'),
        voc: $('#kpi-voc-inline'),
        com: $('#kpi-com-inline'),
        prompt: $('#kpi-prompt-inline'),
        moveDays: $('#kpi-move-days-inline'),
        moveAvg: $('#kpi-move-avg-inline'),
        moveMax: $('#kpi-move-max-inline')
      };
      if (inline.entries) inline.entries.textContent = summary.counts.entries ?? 0;
      if (inline.hygiene) inline.hygiene.textContent = (summary.percents.hygiene_yes ?? 0) + '%';
      if (inline.food) inline.food.textContent = (summary.percents.food_prep_yes ?? 0) + '%';
      if (inline.cleanup) inline.cleanup.textContent = (summary.percents.cleanup_yes ?? 0) + '%';
      if (inline.voc) inline.voc.textContent = summary.totals.vocational_minutes ?? 0;
      if (inline.com) inline.com.textContent = summary.totals.community_minutes ?? 0;
      if (inline.prompt) inline.prompt.textContent = summary.averages.new_skill_score ?? 'â€”';
      if (inline.moveDays) inline.moveDays.textContent = summary.movement?.days ?? 0;
      if (inline.moveAvg) inline.moveAvg.textContent = summary.averages?.movement_severity ?? 'â€”';
      if (inline.moveMax) inline.moveMax.textContent = summary.movement?.max_severity ?? 'â€”';
    }

    function drawHealthChart(series){
      destroy('health');
      if (!series || !series.length) {
        const now = new Date();
        const demo = [];
        for (let i = 2; i >= 0; i--) {
          const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
          const monthKey = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
          demo.push({
            x: monthKey,
            hygiene_yes: 8 + i * 2,
            food_prep_yes: 6 + i * 3,
            cleanup_yes: 5 + i * 2
          });
        }
        series = demo;
      }
      const labels = series?.map(p=>p.x) ?? [];
      const datasets = [
        { label:'Hygiene (Yes)', data: series?.map(p=>p.hygiene_yes)||[], borderRadius:8, backgroundColor:'rgba(59,130,246,.55)' },
        { label:'Food Prepared (Yes)', data: series?.map(p=>p.food_prep_yes)||[], borderRadius:8, backgroundColor:'rgba(16,185,129,.55)' },
        { label:'Clean-up (Yes)', data: series?.map(p=>p.cleanup_yes)||[], borderRadius:8, backgroundColor:'rgba(245,158,11,.6)' },
      ];
      charts.health = new Chart($('#healthChart'), {
        type:'bar',
        data:{ labels, datasets },
        options:{
          responsive:true,
          plugins:{ legend:{ position:'top', labels:{ boxWidth:12, boxHeight:12, font:{ size:12 } } } },
          scales:{
            x:axisTitle('Month'),
            y:{ beginAtZero:true, ticks:{precision:0}, ...axisTitle('Yes count (check-ins)') }
          }
        }
      });
    }

    function drawSkillChart(series){
      destroy('skill');
      if (!series || !series.length) {
        const now = new Date();
        const demo = [];
        for (let i = 6; i >= 0; i--) {
          const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() - i);
          const dayKey = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
          demo.push({ x: dayKey, avg_new_skill_score: [2,3,2,4,3,2,1][6 - i] });
        }
        series = demo;
      }
      const labels = series?.map(p=>p.x) ?? [];
      const data   = series?.map(p=>p.avg_new_skill_score ?? null) ?? [];
      charts.skill = new Chart($('#skillChart'), {
        type:'bar',
        data:{
          labels,
          datasets:[{
            label:'Avg Prompt Level',
            data,
            borderRadius:10,
            backgroundColor:'rgba(248,113,113,.7)',
            borderColor:'rgba(248,113,113,1)',
            borderWidth:1,
            maxBarThickness:36
          }]
        },
        options:{
          responsive:true,
          plugins:{ legend:{ position:'top', labels:{ boxWidth:12, boxHeight:12, font:{ size:12 } } } },
          scales:{
            x:axisTitle('Week'),
            y:{ min:0,max:4,ticks:{stepSize:1, precision:0}, ...axisTitle('Prompt level (0â€“4)') }
          }
        }
      });
    }

    function drawCommunityInteractionChart(counts){
      destroy('communityInteraction');
      const canvas = $('#communityInteractionChart');
      if (!canvas) return;
      const dataSet = Array.isArray(counts) ? counts : [];
      const labels = dataSet.map(item => item.label);
      const data = dataSet.map(item => item.count);
      charts.communityInteraction = new Chart(canvas, {
        type:'bar',
        data:{
          labels,
          datasets:[{
            label:'Interactions',
            data,
            borderRadius:10,
            backgroundColor:'rgba(96,165,250,.7)',
            borderColor:'rgba(59,130,246,1)',
            borderWidth:1,
            maxBarThickness:40
          }]
        },
        options:{
          responsive:true,
          plugins:{ legend:{ position:'top', labels:{ boxWidth:12, boxHeight:12, font:{ size:12 } } } },
          scales:{
            x:{ ticks:{ maxRotation:30, minRotation:30, autoSkip:false }, ...axisTitle('Interaction type') },
            y:{ beginAtZero:true, ticks:{ precision:0 }, ...axisTitle('Count') }
          }
        }
      });
    }

    const MOVEMENT_TYPE_LABELS = {
      hands_shaking: 'Hands shaking',
      face_mouth: 'Face / mouth',
      arms_legs: 'Arms / legs',
      other: 'Other'
    };
    const MOVEMENT_TIME_LABELS = {
      AM: 'Morning',
      PM: 'Afternoon / Evening',
      Overnight: 'Overnight'
    };
    const MOVEMENT_BODY_LABELS = {
      eyes_blinking: 'Eyes blinking / eye movements',
      face_grimacing: 'Face grimacing',
      mouth_lips: 'Mouth / lips',
      tongue_movements: 'Tongue movements',
      jaw_movements: 'Jaw movements',
      hands_tremor: 'Hands tremor',
      arms_jerks: 'Arms jerks',
      legs_feet: 'Legs / feet',
      neck_trunk: 'Neck / trunk',
      other_movement: 'Other movement'
    };
    const MOVEMENT_TRIGGER_LABELS = {
      stress: 'Stress / anxiety',
      around_meds: 'Around meds',
      tired_sleep: 'Tired / poor sleep',
      before_eating: 'Before eating',
      after_eating: 'After eating',
      excitement: 'Excited / overstimulated',
      unknown: 'Unknown',
      other: 'Other'
    };

    function buildMovementInsights(entries){
      const daily = new Map();
      const typeCounts = {};
      const bodyCounts = {};
      const triggerCounts = {};
      const timeCounts = {};
      let severityTotal = 0;
      let severityCount = 0;
      let maxSeverity = null;
      const daySet = new Set();
      entries.forEach((entry) => {
        const movement = movementFromEntry(entry);
        if (!movement.present) return;
        const dayKey = dayKeyFor(entry);
        if (dayKey) {
          const bucket = daily.get(dayKey) || { severities: [] };
          if (movement.severity !== null) bucket.severities.push(movement.severity);
          daily.set(dayKey, bucket);
          daySet.add(dayKey);
        }
        if (movement.severity !== null) {
          severityTotal += movement.severity;
          severityCount += 1;
          if (maxSeverity === null || movement.severity > maxSeverity) {
            maxSeverity = movement.severity;
          }
        }
        const typeKey = movement.mainType || 'other';
        typeCounts[typeKey] = (typeCounts[typeKey] || 0) + 1;
        movement.bodyMap.forEach((item) => {
          if (!item) return;
          bodyCounts[item] = (bodyCounts[item] || 0) + 1;
        });
        movement.triggers.forEach((item) => {
          if (!item) return;
          triggerCounts[item] = (triggerCounts[item] || 0) + 1;
        });
        const times = parseMovementArray(entry.movement_times ?? entry.payload?.movement_times);
        times.forEach((item) => {
          if (!item) return;
          timeCounts[item] = (timeCounts[item] || 0) + 1;
        });
      });
      const severitySeries = Array.from(daily.entries())
        .sort(([a],[b]) => a.localeCompare(b))
        .map(([day, bucket]) => ({
          x: day,
          y: bucket.severities.length
            ? Math.round(bucket.severities.reduce((sum, val) => sum + val, 0) / bucket.severities.length)
            : null
        }));
      const topN = (counts, limit = 5) =>
        Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,limit)
          .reduce((acc, [key, val]) => { acc[key] = val; return acc; }, {});
      const mostCommon = (counts) => {
        const entries = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
        return entries.length ? entries[0][0] : null;
      };
      return {
        severitySeries,
        typeCounts: topN(typeCounts),
        bodyCounts: topN(bodyCounts),
        triggerCounts: topN(triggerCounts),
        daysWithSymptoms: daySet.size,
        avgSeverity: severityCount ? Math.round(severityTotal / severityCount) : null,
        maxSeverity,
        mostCommonType: mostCommon(typeCounts),
        mostCommonTime: mostCommon(timeCounts)
      };
    }

    function buildDemoMovementInsights(){
      const now = new Date();
      const severitySeries = [];
      for (let i = 6; i >= 0; i--) {
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() - i);
        const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
        severitySeries.push({ x: key, y: [1,2,2,3,2,1,2][6 - i] });
      }
      return {
        severitySeries,
        typeCounts: { hands_shaking: 6, arms_legs: 4, face_mouth: 3, other: 2 },
        bodyCounts: { hands_tremor: 5, mouth_lips: 4, jaw_movements: 3, legs_feet: 3, neck_trunk: 2 },
        triggerCounts: { tired_sleep: 5, around_meds: 3, stress: 3, excitement: 2, unknown: 1 },
        daysWithSymptoms: 6,
        avgSeverity: 2,
        maxSeverity: 3,
        mostCommonType: 'hands_shaking',
        mostCommonTime: 'PM'
      };
    }

    function drawMovementSeverityChart(series){
      destroy('movementSeverity');
      if (!series || !series.length) {
        series = buildDemoMovementInsights().severitySeries;
      }
      const labels = series?.map(p=>p.x) ?? [];
      const data   = series?.map(p=>p.y ?? null) ?? [];
      charts.movementSeverity = new Chart($('#movementSeverityChart'), {
        type:'line',
        data:{ labels, datasets:[{ data, tension:.35, pointRadius:0, borderColor:'#1d4ed8', borderWidth:2, fill:false }]},
        options:{
          responsive:true,
          plugins:{ legend:{ display:false }, tooltip:{ enabled:true } },
          scales:{
            x:{
              display:true,
              title:{ display:true, text:'Date' },
              ticks:{ maxTicksLimit:4 }
            },
            y:{
              display:true,
              min:0,
              max:4,
              title:{ display:true, text:'Severity (0â€“4)' },
              ticks:{ stepSize:1 }
            }
          }
        }
      });
    }

    function drawMovementTypeChart(counts = {}){
      destroy('movementType');
      if (!counts || !Object.keys(counts).length) {
        counts = buildDemoMovementInsights().typeCounts;
      }
      const labels = Object.keys(counts).map(key => MOVEMENT_TYPE_LABELS[key] || key);
      const data = Object.keys(counts).map(key => counts[key]);
      charts.movementType = new Chart($('#movementMainTypeChart'), {
        type:'bar',
        data:{ labels, datasets:[{ data, backgroundColor:'#93c5fd', borderRadius:8 }]},
        options:{
          responsive:true,
          indexAxis:'y',
          plugins:{ legend:{ display:false }, tooltip:{ enabled:true } },
          scales:{
            x:{ display:true, beginAtZero:true, ...axisTitle('Count') },
            y:{ display:true, ...axisTitle('Type'), ticks:{ autoSkip:false } }
          }
        }
      });
    }

    function drawMovementBodyChart(counts = {}){
      destroy('movementBody');
      if (!counts || !Object.keys(counts).length) {
        counts = buildDemoMovementInsights().bodyCounts;
      }
      const sorted = Object.entries(counts);
      const labels = sorted.map(([key]) => MOVEMENT_BODY_LABELS[key] || key);
      const data = sorted.map(([,val]) => val);
      charts.movementBody = new Chart($('#movementBodyMapChart'), {
        type:'bar',
        data:{ labels, datasets:[{ data, backgroundColor:'#fcd34d', borderRadius:8 }]},
        options:{
          responsive:true,
          indexAxis:'y',
          plugins:{ legend:{ display:false }, tooltip:{ enabled:true } },
          scales:{
            x:{ display:true, beginAtZero:true, title:{ display:true, text:'Count' } },
            y:{ display:true, title:{ display:true, text:'Body area' } }
          }
        }
      });
    }

    function drawMovementTriggerChart(counts = {}){
      destroy('movementTrigger');
      if (!counts || !Object.keys(counts).length) {
        counts = buildDemoMovementInsights().triggerCounts;
      }
      const sorted = Object.entries(counts);
      const labels = sorted.map(([key]) => MOVEMENT_TRIGGER_LABELS[key] || key);
      const data = sorted.map(([,val]) => val);
      charts.movementTrigger = new Chart($('#movementTriggerChart'), {
        type:'bar',
        data:{ labels, datasets:[{ data, backgroundColor:'#a7f3d0', borderRadius:8 }]},
        options:{
          responsive:true,
          indexAxis:'y',
          plugins:{ legend:{ display:false }, tooltip:{ enabled:true } },
          scales:{
            x:{ display:true, beginAtZero:true, ...axisTitle('Count') },
            y:{ display:true, ...axisTitle('Trigger'), ticks:{ autoSkip:false } }
          }
        }
      });
    }

    async function loadCaregiverData(){
      let res = null;
      await ensureActiveGroupId(USER_ID);

      if (loadFromSupabase){
        try {
          res = await loadFromSupabase(USER_ID, {
            range: 'all',
            includeAllUsers: true
          });
        } catch {}
      }

      // If no rows from Supabase, keep structures valid
      if (!res || !Array.isArray(res.entries)) {
        const entries = [];
        res = {
          entries,
          summary:{
            counts:{entries:0},
            percents:{hygiene_yes:0,food_prep_yes:0,cleanup_yes:0},
            totals:{vocational_minutes:0,community_minutes:0},
            averages:{new_skill_score:'â€”'}
          },
          charts:{ monthly: [], promptDaily: [] }
        };
      }

      let entries = (res.entries || []).filter(entry => !isCalendarOnlyEntry(entry));
      if (!entries.length) {
        entries = buildDemoCaregiverEntries(new Date());
      }
      const summary = summarizeEntries(entries);
      const { monthly, promptDaily } = buildMonthlySeries(entries);
      const movementInsights = buildMovementInsights(entries);
      const rangeKey = document.getElementById('chartRangeSelect')?.value || 'month';
      const range = getChartRangeWindow(rangeKey, entries);
      const filteredForRange = filterEntriesByRange(entries, range);

      window.latestCaregiverEntries = entries.slice();
      renderKPIs(summary);
      drawHealthChart(truncateSeries(monthly, rangeKey));
      drawSkillChart(truncateSeries(promptDaily, rangeKey));
      drawCommunityInteractionChart(buildCommunityInteractionCounts(filteredForRange));
      renderActivityTypeQuickLook(buildActivityTypeCounts(filteredForRange));
      drawMovementSeverityChart(movementInsights.severitySeries);
      drawMovementTypeChart(movementInsights.typeCounts);
      drawMovementBodyChart(movementInsights.bodyCounts);
      drawMovementTriggerChart(movementInsights.triggerCounts);
      const summaryDays = document.getElementById('movementDaysVal');
      const summaryAvg = document.getElementById('movementAvgVal');
      const summaryMax = document.getElementById('movementMaxVal');
      const summaryType = document.getElementById('movementTypeVal');
      const summaryTime = document.getElementById('movementTimeVal');
      if (summaryDays) summaryDays.textContent = movementInsights.daysWithSymptoms ?? 0;
      if (summaryAvg) summaryAvg.textContent = movementInsights.avgSeverity ?? 'â€”';
      if (summaryMax) summaryMax.textContent = movementInsights.maxSeverity ?? 'â€”';
      if (summaryType) {
        const label = MOVEMENT_TYPE_LABELS[movementInsights.mostCommonType] || movementInsights.mostCommonType || 'â€”';
        summaryType.textContent = label;
      }
      if (summaryTime) {
        const label = MOVEMENT_TIME_LABELS[movementInsights.mostCommonTime] || movementInsights.mostCommonTime || 'â€”';
        summaryTime.textContent = label;
      }
      cgState.entries = entries.slice();
      cgState.entryById = new Map();
      entries.forEach(entry => {
        if (entry?.id) cgState.entryById.set(String(entry.id), entry);
      });
      cgState.focusStats = buildFocusStats(entries);
      populateCaregiverOptions(cgState.entries);
      updateDateInputs(cgState.entries);
      applyCaregiverFilters();
      if (currentFocusPlan) {
        renderFocusGoalList(currentFocusPlan.goals || []);
        renderFocusGoalChart(currentFocusPlan.goals || []);
      }
      window.dispatchEvent(new Event('caregiverDataReady'));
    }

    /* =================== Mood data + charts =================== */
    const MOOD_GROUPS = {
      Positive:["Happy","Proud","Cool","Loved"],
      "Low Energy":["OK","Neutral","Bored","Tired","Confused"],
      Challenging:["Anxious","Worried","Scared","Mad","Frustrated","Sad","Crying","Sick","Headache","Nauseous"],
      Other:["Hungry","Thirsty"]
    };
    const toBucket = m => Object.entries(MOOD_GROUPS).find(([_,list])=>list.includes(m))?.[0] || 'Other';

    function moodBoundsFor(viewRange){
      const now=new Date(); let start=new Date(0);
      if(viewRange==='day'){ start=new Date(now); start.setHours(0,0,0,0); }
      else if(viewRange==='month'){ start=new Date(now.getFullYear(),now.getMonth(),1); }
      else if(viewRange==='year'){ start=new Date(now.getFullYear(),0,1); }
      else if(viewRange==='6months'){ start=new Date(now); start.setDate(start.getDate()-183); }
      return { start, end: now };
    }

    async function fetchMoodEntries(viewRange){
      const { start, end } = moodBoundsFor(viewRange);
      const startISO = start.toISOString();
      const endISO   = end.toISOString();

      const toNumber = (value) => {
        if (value === null || value === undefined || value === '') return null;
        if (typeof value === 'number') return Number.isFinite(value) ? value : null;
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) return null;
          const direct = Number(trimmed);
          if (Number.isFinite(direct)) return direct;
          if (/\b10\+|\bten\+/i.test(trimmed)) return 10;
          const range = trimmed.match(/(-?\d+(?:\.\d+)?)\s*(?:[-â€“to]+\s*)(-?\d+(?:\.\d+)?)/i);
          if (range) {
            const upper = Number(range[2]);
            if (Number.isFinite(upper)) return upper;
          }
          const match = trimmed.match(/-?\d+(?:\.\d+)?/);
          if (match) {
            const parsed = Number(match[0]);
            if (Number.isFinite(parsed)) return parsed;
          }
        }
        return null;
      };

      const pickSleepHours = (row) => {
        const candidates = [
          row?.sleep_hours,
          row?.sleepHours,
          row?.sleep,
          row?.hours_sleep,
          row?.hoursSleep,
          row?.payload?.sleep_hours,
          row?.payload?.sleepHours,
          row?.payload?.hours_sleep,
          row?.content?.sleep_hours,
          row?.content_json?.sleep_hours,
          row?.content_json?.hours_sleep,
          row?.notes?.sleep_hours
        ];
        for (const value of candidates) {
          const num = toNumber(value);
          if (num !== null) return num;
        }
        return null;
      };

      // 1) Remote rows (use BOTH date and created_at safely)
      let supaRows = [];
      try {
        const query = [
          'select=*',
          `created_at=gte.${encodeURIComponent(startISO)}`,
          `created_at=lte.${encodeURIComponent(endISO)}`,
          'order=created_at.asc',
        ].join('&');
        const data = await rest(`mood_entries?${query}`);
        if (Array.isArray(data)) {
          supaRows = data.map(r => {
            const ts = r.date ? new Date(r.date) : new Date(r.created_at || r.timestamp || Date.now());
            const sleep = pickSleepHours(r);
            return {
              id: `s:${ts.toISOString()}:${r.id ?? ''}`,
              timestamp: ts.toISOString(),
              dateObj: ts,
              mood: r.mood || 'Unknown',
              intensity: toNumber(r.intensity),
              notes: r.notes ?? r.note ?? null,
              sleep_hours: sleep,
              source: 'supabase'
            };
          });
        }
      } catch (e) {
        console.warn('fetchMoodEntries REST error', e?.message || e);
      }

      // 2) Local rows fallback
      const localRows = (JSON.parse(localStorage.getItem('moodEntries') || '[]'))
        .filter(r => {
          const ts = new Date(r.timestamp || r.created_at || r.date || Date.now());
          return ts >= start && ts <= end;
        })
        .map(r => {
          const ts = new Date(r.timestamp || r.created_at || r.date || Date.now());
          return {
            id: `l:${ts.toISOString()}:${r.mood||''}:${r.intensity??''}`,
            timestamp: ts.toISOString(),
            dateObj: ts,
            mood: r.mood || 'Unknown',
            intensity: toNumber(r.intensity),
            notes: r.notes ?? r.note ?? null,
            sleep_hours: toNumber(r.sleep_hours),
            source: 'local'
          };
        });

      // 3) Merge & de-dupe (prefer Supabase)
      const byKey = new Map();
      [...supaRows, ...localRows].forEach(row => {
        const key = `${row.timestamp}|${row.mood}|${row.intensity ?? ''}`;
        if (!byKey.has(key) || row.source === 'supabase') byKey.set(key, row);
      });

      return [...byKey.values()].sort((a,b) => a.dateObj - b.dateObj);
    }


    let pieMain=null;
    function drawMoodShare(indivCounts){
      if (pieMain) pieMain.destroy();
      let labels=Object.keys(indivCounts), data=Object.values(indivCounts);
      if (!labels.length){ labels=['Loved','OK','Confused','Hungry']; data=[6,3,2,1]; }
      const colors=labels.map((_,i)=>`hsl(${(i*360)/Math.max(labels.length,1)},70%,60%)`);
      pieMain = new Chart($('#moodPieMain'), { type:'pie', data:{labels, datasets:[{data, backgroundColor:colors}]} });
    }

    function drawEngagementVsMood(moodEntries, caregiverEntries){
      const caregiver=(caregiverEntries || window.latestCaregiverEntries || []).slice();
      const buckets=['Positive','Low Energy','Challenging','Other'];
      const countsByDay=new Map();
      for (const e of moodEntries){
        const key = dayKey(e.dateObj);
        const obj=countsByDay.get(key)||{Positive:0,"Low Energy":0,Challenging:0,Other:0};
        obj[toBucket(e.mood)]++; countsByDay.set(key,obj);
      }
      const domBucketByDay=new Map([...countsByDay.entries()].map(([k,v])=>[k, Object.entries(v).sort((a,b)=>b[1]-a[1])[0][0]]));
      const keys=['home_time','vocational_time','community_time','leisure_time'];
      const sums={Positive:{}, "Low Energy":{}, Challenging:{}, Other:{}}, counts={Positive:0,"Low Energy":0,Challenging:0,Other:0};
      for(const e of caregiver){
        const key=dayKey(new Date(e.timestamp||e.created_at||Date.now()));
        const b=domBucketByDay.get(key)||'Other'; counts[b]+=1;
        for(const k of keys){ if(e[k]!=null) sums[b][k]=(sums[b][k]||0)+(+e[k]||0); }
      }
      const present = keys.filter(k=>Object.values(sums).some(o=>o[k]!=null));
      let datasets = present.map(k=>({
        label:({home_time:'Home',vocational_time:'Vocational',community_time:'Community',leisure_time:'Leisure'})[k],
        data: ['Positive','Low Energy','Challenging','Other'].map(b=> counts[b] ? +( (sums[b][k]||0) / counts[b]).toFixed(1) : 0 )
      }));
      if (!datasets.length || datasets.every(ds => ds.data.reduce((a,b)=>a+b,0)===0)){
        datasets = [
          {label:'Home', data:[50,88,120,72]},
          {label:'Vocational', data:[90,55,40,65]},
          {label:'Community', data:[88,38,36,52]},
          {label:'Leisure', data:[36,60,45,48]}
        ];
      }
      new Chart($('#engagementVsMood'), {
        type:'bar',
        data:{ labels:buckets, datasets },
        options:{ responsive:true, scales:{ x:axisTitle('Mood Bucket'), y:{ beginAtZero:true, ...axisTitle('Average Minutes') } } }
      });
    }

    function pearson(xs,ys){
      const n=xs.length; if(n<3) return null;
      const mx=xs.reduce((a,b)=>a+b,0)/n, my=ys.reduce((a,b)=>a+b,0)/n;
      let num=0,dx=0,dy=0; for(let i=0;i<n;i++){ const x=xs[i]-mx,y=ys[i]-my; num+=x*y; dx+=x*x; dy+=y*y; }
      const den=Math.sqrt(dx*dy); return den ? +(num/den).toFixed(3) : null;
    }

    function parseSleepHours(val){
      if (val === null || val === undefined || val === '') return null;
      if (typeof val === 'number') return Number.isFinite(val) ? val : null;
      const str = String(val).trim();
      if (!str) return null;
      const direct = Number(str);
      if (Number.isFinite(direct)) return direct;
      if (/\b10\+|\bten\+/i.test(str)) return 10;
      const range = str.match(/(-?\d+(?:\.\d+)?)\s*(?:[-â€“to]+\s*)(-?\d+(?:\.\d+)?)/i);
      if (range) {
        const upper = Number(range[2]);
        if (Number.isFinite(upper)) return upper;
      }
      const match = str.match(/-?\d+(?:\.\d+)?/);
      if (match) {
        const parsed = Number(match[0]);
        if (Number.isFinite(parsed)) return parsed;
      }
      return null;
    }

    function caregiverSleepHours(entry){
      const payload = entry?.payload || {};
      const candidates = [
        entry?.sleep_hours,
        entry?.hours_sleep,
        payload.sleep_hours,
        payload.hours_sleep,
        payload.sleepHours,
        payload.hoursSleep,
        payload.sleep_duration,
        payload.sleepDuration
      ];
      for (const val of candidates){
        const hrs = parseSleepHours(val);
        if (hrs !== null) return hrs;
      }
      return null;
    }

    /* =================== WYR =================== */
    async function fetchWyr(){
      let rows=[];
      try{
        const data = await rest('wyr_entries?select=created_at,choice,activity,label&order=created_at.asc');
        rows = (data||[]).map(r=>({ ts:new Date(r.created_at), label:(r.label||r.activity||r.choice||'Unknown') }));
      }catch(e){
        console.warn('fetchWyr REST error', e);
      }
      if (!rows.length){
        rows = (JSON.parse(localStorage.getItem('wyrEntries')||'[]')).map(r=>({ ts:new Date(r.timestamp), label:r.label }));
      }
      // DEMO fallback: generate simple picks if nothing is present
      if (!rows.length){
        const labels = ['Hike','Puzzles','Music','Walk','Store'];
        const start = new Date(Date.UTC(2026, 0, 1));
        for (let i=0; i<30; i++){
          const ts = new Date(start.getTime() + i * 86400000 + 16 * 3600000);
          rows.push({ ts, label: labels[i % labels.length] });
        }
      }
      return rows;
    }
    const FORCE_WYR_GRAPHIC = false;
    let wyrRenderInFlight = false;
    async function renderWyr(){
      if (wyrRenderInFlight) return;
      wyrRenderInFlight = true;
      try {
        const canvas = $('#wyrBar');
        if (!canvas) return;
        canvas.style.display = '';
        canvas.style.width = '100%';
        canvas.style.height = '220px';
        // Ensure canvas has a drawable size (demo safeguard)
        if (canvas.clientHeight === 0) {
          canvas.style.minHeight = '220px';
          canvas.height = 220;
        }
        const rows = await fetchWyr();
        const cg = (window.latestCaregiverEntries||[]);
        const leisureByDay = new Map();
        for(const e of cg){
          const d=(e.timestamp||e.created_at||'').slice(0,10);
          const add=+e.leisure_time||0;
          leisureByDay.set(d,(leisureByDay.get(d)||0)+add);
        }
        const picksByDay=new Map();
        for(const r of rows){
          const k=r.ts.toISOString().slice(0,10);
          (picksByDay.get(k)||picksByDay.set(k,[]).get(k)).push(r.label);
        }

        const totals={}, counts={};
        for(const [day,labels] of picksByDay){
          const mins = leisureByDay.get(day)||0;
          const share = labels.length ? mins/labels.length : 0;
          for (const lbl of labels){ totals[lbl]=(totals[lbl]||0)+share; counts[lbl]=(counts[lbl]||0)+1; }
        }
        let labels=Object.keys(totals);
        let minutes = labels.map(l=>+(totals[l]||0).toFixed(1));
        let picks   = labels.map(l=>counts[l]||0);

        // DEMO fallback: force a visible chart
        const demoLabels = ['Hike','Puzzles','Music','Walk','Store'];
        const demoMinutes = [140,110,95,80,70];
        const demoPicks = [7,6,5,5,4];
        const minutesEmpty = !minutes.length || minutes.every(v=>!v);
        const picksEmpty = !picks.length || picks.every(v=>!v);
        if (!labels.length || minutesEmpty || picksEmpty){
          labels = demoLabels;
          minutes = demoMinutes;
          picks = demoPicks;
        }

        const graphic = document.getElementById('wyrGraphic');
        const fallbackId = 'wyrFallback';
        let fallback = document.getElementById(fallbackId);

        if (!window.Chart) {
          canvas.style.display = 'none';
          if (graphic) graphic.classList.remove('is-hidden');
          if (fallback) fallback.remove();
          $('#wyrNote').textContent = 'Bars = total leisure minutes credited to each choice; line = number of picks.';
          return;
        }

        if (FORCE_WYR_GRAPHIC) {
          canvas.style.display = 'none';
          if (graphic) graphic.classList.remove('is-hidden');
          if (fallback) fallback.remove();
          $('#wyrNote').textContent = 'Bars = total leisure minutes credited to each choice; line = number of picks.';
          return;
        }

        let rendered = false;
        try{
          const existing = window.Chart?.getChart ? window.Chart.getChart(canvas) : null;
          if (existing) existing.destroy();
          charts.wyr && charts.wyr.destroy();
          charts.wyr = new Chart(canvas,{
            type:'bar',
            data:{
              labels,
              datasets:[
                { type:'bar',  label:'Total Leisure Minutes', data:minutes, yAxisID:'y', datalabels:{formatter:v=>v?`${v} min`:'',anchor:'end',align:'top',font:{size:10}}},
                { type:'line', label:'Number of Picks', data:picks,   yAxisID:'y1', tension:.25, pointRadius:3 }
              ]
            },
            options:{ responsive:true, interaction:{mode:'index',intersect:false},
              scales:{ y:{beginAtZero:true,...axisTitle('Minutes')}, y1:{beginAtZero:true,position:'right',grid:{drawOnChartArea:false},...axisTitle('Picks')} } }
          });
          rendered = true;
        }catch(e){
          console.warn('renderWyr failed', e);
        }
        $('#wyrNote').textContent = 'Bars = total leisure minutes credited to each choice (split across multiple picks in a day). Line = number of picks.';
        if (canvas.clientWidth === 0 || canvas.clientHeight === 0) rendered = false;
        // Text fallback if Chart.js fails to render
        if (!rendered) {
          canvas.style.display = 'none';
          if (graphic) graphic.classList.remove('is-hidden');
          if (!fallback) {
            fallback = document.createElement('div');
            fallback.id = fallbackId;
            fallback.style.marginTop = '12px';
            fallback.style.fontSize = '13px';
            fallback.style.color = '#374151';
            canvas.parentElement?.appendChild(fallback);
          }
          fallback.innerHTML = labels.map((label, idx) =>
            `<div><strong>${label}</strong>: ${minutes[idx]} min, ${picks[idx]} picks</div>`
          ).join('');
        } else if (fallback) {
          canvas.style.display = '';
          if (graphic) graphic.classList.add('is-hidden');
          fallback.remove();
        }
      } finally {
        wyrRenderInFlight = false;
      }
    }

    /* =================== Export helpers =================== */
    async function exportElement(selector, fileName){
      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
      const { jsPDF } = window.jspdf;
      const el = document.querySelector(selector); if (!el) return;

      const w = el.scrollWidth, h = el.scrollHeight;
      const canvas = await html2canvas(el, {
        scale: 2, backgroundColor: '#ffffff',
        width: w, height: h, windowWidth: w, windowHeight: h,
        scrollX: 0, scrollY: -window.scrollY
      });

      const img = canvas.toDataURL('image/png');
      const pdf = new jsPDF({ unit:'pt', format:'a4' });
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const imgW = pageW;
      const imgH = canvas.height * (imgW / canvas.width);

      let heightLeft = imgH;
      let y = 0;
      pdf.addImage(img, 'PNG', 0, 0, imgW, imgH);
      heightLeft -= pageH;
      while (heightLeft > 0) {
        pdf.addPage();
        y = heightLeft - imgH;
        pdf.addImage(img, 'PNG', 0, y, imgW, imgH);
        heightLeft -= pageH;
      }
      pdf.save(fileName);
    }
    window.exportElement = window.exportElement || exportElement;

    async function exportElementToBlob(selector){
      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
      const { jsPDF } = window.jspdf;
      const el = document.querySelector(selector); if (!el) return null;

      const w = el.scrollWidth, h = el.scrollHeight;
      const canvas = await html2canvas(el, {
        scale: 2, backgroundColor: '#ffffff',
        width: w, height: h, windowWidth: w, windowHeight: h,
        scrollX: 0, scrollY: -window.scrollY
      });

      const img = canvas.toDataURL('image/png');
      const pdf = new jsPDF({ unit:'pt', format:'a4' });
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const imgW = pageW;
      const imgH = canvas.height * (imgW / canvas.width);

      let heightLeft = imgH;
      let y = 0;
      pdf.addImage(img, 'PNG', 0, 0, imgW, imgH);
      heightLeft -= pageH;
      while (heightLeft > 0) {
        pdf.addPage();
        y = heightLeft - imgH;
        pdf.addImage(img, 'PNG', 0, y, imgW, imgH);
        heightLeft -= pageH;
      }
      return pdf.output('blob');
    }

    async function shareCaregiverPdf(){
      if (!cgState.entries.length) {
        alert('No caregiver data to export yet.');
        return;
      }
      const btn = cgInputs.sharePdf;
      if (btn) {
        btn.disabled = true;
        btn.dataset.original = btn.textContent;
        btn.textContent = 'Preparingâ€¦';
      }
      setCaregiverNotesExportMode(true);
      try {
        const blob = await exportElementToBlob('#cg-panel');
        if (!blob) throw new Error('PDF failed');
        const fileName = `Caregiver_Checkins_${new Date().toISOString().slice(0,10)}.pdf`;
        const file = new File([blob], fileName, { type: 'application/pdf' });
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
          await navigator.share({ files: [file], title: 'Caregiver Check-Ins' });
        } else {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
      } catch (error) {
        console.error('Share PDF failed', error);
        alert('Unable to create a PDF right now.');
      } finally {
        setCaregiverNotesExportMode(false);
        if (btn) {
          btn.disabled = false;
          btn.textContent = btn.dataset.original || 'ğŸ“¤ Share PDF';
        }
      }
    }

    /* =================== Wire & boot =================== */
    $('#moodRange').addEventListener('change', renderMoodSection);
    document.getElementById('chartRangeSelect')?.addEventListener('change', applyChartRange);
    document.getElementById('movementRangeSelect')?.addEventListener('change', (event) => {
      const rangeKey = event.target.value || 'month';
      applyMovementRange(rangeKey);
    });

    // Event delegation keeps row actions working as the table refreshes.
    cgInputs.tbody?.addEventListener('click', (event) => {
      const noteBtn = event.target.closest('.cg-note-btn');
      if (noteBtn) {
        const checkinId = noteBtn.dataset.checkinId;
        let entry = null;
        if (checkinId) entry = cgState.entryById.get(String(checkinId));
        if (!entry && noteBtn.dataset.rowIndex) {
          entry = cgState.filtered[Number(noteBtn.dataset.rowIndex)] || null;
        }
        if (entry) openNoteDrawer(entry);
        return;
      }
      const btn = event.target.closest('.cg-edit-btn');
      if (!btn) return;
      const checkinId = btn.dataset.checkinId;
      if (checkinId) {
        openEditModal(checkinId);
      }
    });

    editUi.cancel?.addEventListener('click', () => closeEditModal());
    editUi.form?.addEventListener('submit', handleUpdateCheckin);
    editUi.overlay?.addEventListener('click', (event) => {
      if (event.target === editUi.overlay) closeEditModal();
    });
    noteUi.overlay?.addEventListener('click', (event) => {
      if (event.target === noteUi.overlay) closeNoteDrawer();
    });
    noteUi.close?.addEventListener('click', () => closeNoteDrawer());
    noteUi.closeFooter?.addEventListener('click', () => closeNoteDrawer());
    noteUi.edit?.addEventListener('click', () => {
      const checkinId = noteUi.edit?.dataset.checkinId;
      if (checkinId) {
        closeNoteDrawer();
        openEditModal(checkinId);
      }
    });
    document.addEventListener('keydown', (event) => {
      if (event.key !== 'Escape') return;
      if (!editUi.overlay?.classList.contains('is-hidden')) closeEditModal();
      if (!noteUi.overlay?.classList.contains('is-hidden')) closeNoteDrawer();
    });

    cgInputs.apply?.addEventListener('click', (event) => {
      event?.preventDefault?.();
      console.log('[Caregiver Report] Apply clicked');
      applyCaregiverFilters();
    });
    cgInputs.start?.addEventListener('change', () => applyCaregiverFilters());
    cgInputs.end?.addEventListener('change', () => applyCaregiverFilters());
    cgInputs.caregiver?.addEventListener('change', () => {
      cgState.caregiverFilter = cgInputs.caregiver.value || 'all';
      applyCaregiverFilters();
    });
    cgInputs.notesToggle?.addEventListener('click', () => {
      const expanded = !document.body.classList.contains('cg-notes-expanded');
      document.body.classList.toggle('cg-notes-expanded', expanded);
      cgInputs.notesToggle.setAttribute('aria-pressed', expanded ? 'true' : 'false');
      cgInputs.notesToggle.textContent = expanded ? 'Compact notes' : 'Expand notes';
    });
    document.querySelectorAll('.cg-clear-filters').forEach(btn => {
      btn.addEventListener('click', () => clearCaregiverFilters());
    });
    cgInputs.csv?.addEventListener('click', exportCaregiverCsv);
    cgInputs.pdf?.addEventListener('click', exportCaregiverPdf);
    cgInputs.sharePdf?.addEventListener('click', shareCaregiverPdf);
    quickLookUi.toggle?.addEventListener('click', () => toggleQuickLook());
    quickLookUi.close?.addEventListener('click', () => toggleQuickLook(false));

    async function renderMoodSection(){
      const rangeSel = $('#moodRange').value || 'all';
      const full = await fetchMoodEntries(rangeSel);
      const exportRange = window.exportDateRange || null;
      const inExportRange = (dateObj) => {
        if (!exportRange?.start || !exportRange?.end) return true;
        return dateObj >= exportRange.start && dateObj <= exportRange.end;
      };
      const filteredMood = exportRange ? full.filter(entry => inExportRange(entry.dateObj)) : full;

      // Limit table to last 7 distinct days if "all"
      let tableRows = filteredMood.slice();
      if (rangeSel==='all'){
        const seen=new Set(); const trimmed=[];
        for(let i=tableRows.length-1;i>=0 && seen.size<7;i--){
          const d=tableRows[i].dateObj.toISOString().slice(0,10);
          if (!seen.has(d)) seen.add(d);
          trimmed.unshift(tableRows[i]);
        }
        tableRows = trimmed;
      }

      const tb=$('#moodTable tbody');
      tb.innerHTML = tableRows.length ? '' : `<tr><td colspan="4">No mood check-ins found (showing placeholder data in charts).</td></tr>`;
      for (const e of tableRows){
        tb.insertAdjacentHTML('beforeend', `<tr><td>${e.timestamp}</td><td>${e.mood}</td><td>${e.intensity ?? 'N/A'}</td><td>${e.notes||'â€”'}</td></tr>`);
      }

      let indiv={}, buckets={"Positive":0,"Low Energy":0,"Challenging":0,"Other":0};
      for (const e of filteredMood){ const m=e.mood||'Unknown'; indiv[m]=(indiv[m]||0)+1; buckets[toBucket(m)]++; }
      const totalMood = filteredMood.length || 0;
      const commonMoodEntry = Object.entries(indiv).sort((a,b)=>b[1]-a[1])[0];
      const commonMood = commonMoodEntry ? commonMoodEntry[0] : 'â€”';
      const pct = (count) => totalMood ? `${Math.round((count / totalMood) * 100)}%` : 'â€”';
      $('#moodSummaryTotal').textContent = totalMood ? `${totalMood}` : 'â€”';
      $('#moodSummaryCommon').textContent = commonMood;
      $('#moodSummaryPositive').textContent = pct(buckets.Positive || 0);
      $('#moodSummaryChallenging').textContent = pct(buckets.Challenging || 0);
      $('#moodSummaryTotalInline').textContent = totalMood ? `${totalMood}` : 'â€”';
      $('#moodSummaryCommonInline').textContent = commonMood;
      $('#moodSummaryPositiveInline').textContent = pct(buckets.Positive || 0);
      $('#moodSummaryChallengingInline').textContent = pct(buckets.Challenging || 0);
      drawMoodShare(indiv);
      window.latestMoodEntries = filteredMood.slice();
      applyChartRange();
    }

    window.renderMoodSection = renderMoodSection;

    window.caregiverReportApi = {
      cgInputs,
      formatDateInputValue,
      parseCaregiverDate,
      applyCaregiverFilters,
      renderMoodSection,
      updateFocusPdfSummary,
      getCurrentFocusPlan: () => currentFocusPlan
    };

    await ensureActiveGroupId(USER_ID);
    await loadCaregiverData();
    await loadFocusPanel();
    await renderMoodSection();
    applyChartRange();
    await renderWyr();
    // DEMO safeguard: retry render in case canvas wasn't ready
    setTimeout(() => { renderWyr().catch(()=>{}); }, 800);
    setTimeout(() => { renderWyr().catch(()=>{}); }, 2000);
</script>

</body>
</html>

<!-- Non-module helper scripts kept as-is -->
<script>
  // Hide elements with .no-export while exporting
  function toggleExportHiders(hide) {
    document.querySelectorAll('.no-export').forEach(el => {
      el.style.visibility = hide ? 'hidden' : '';
    });
  }

  async function buildFullReportPdfBlob(sections){
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ unit:'pt', format:'a4' });
    const pageW = pdf.internal.pageSize.getWidth();
    const pageH = pdf.internal.pageSize.getHeight();
    const margin = 36;
    const scale = window.innerWidth <= 720 ? 1.6 : 2;

    for (let i = 0; i < sections.length; i++) {
      const section = sections[i];
      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
      const canvas = await html2canvas(section, {
        scale,
        backgroundColor: '#ffffff',
        width: section.scrollWidth,
        height: section.scrollHeight,
        scrollX: 0,
        scrollY: -window.scrollY
      });
      const aspect = canvas.height / canvas.width || 1;
      let imgW = pageW - margin * 2;
      let imgH = imgW * aspect;
      if (imgH > pageH - margin * 2) {
        imgH = pageH - margin * 2;
        imgW = imgH / aspect;
      }
      if (i > 0) pdf.addPage();
      const label = section.getAttribute('data-print-section');
      if (label) {
        pdf.setFontSize(14);
        pdf.text(label, margin, margin - 12);
      }
      const offsetX = (pageW - imgW) / 2;
      pdf.addImage(canvas.toDataURL('image/png'), 'PNG', offsetX, margin, imgW, imgH);
    }
    return pdf.output('blob');
  }

  async function exportFullReportPDF() {
    const sections = [...document.querySelectorAll('[data-print-section]')];
    if (!sections.length) {
      alert('No printable sections found.');
      return;
    }
    const exportRange = await getExportRangeSelection();
    if (!exportRange) return;
    toggleExportHiders(true);
    document.body.classList.add('print-export');
    document.body.classList.add('export-wide');
    window.setCaregiverNotesExportMode?.(true);
    const api = window.caregiverReportApi || {};
    const cgStart = api.cgInputs?.start || document.getElementById('cgStart');
    const cgEnd = api.cgInputs?.end || document.getElementById('cgEnd');
    const previousRange = { start: cgStart?.value || '', end: cgEnd?.value || '' };
    window.exportDateRange = exportRange;
    if (cgStart) cgStart.value = exportRange.startInput;
    if (cgEnd) cgEnd.value = exportRange.endInput;
    api.applyCaregiverFilters?.();
    await api.renderMoodSection?.();
    api.updateFocusPdfSummary?.(api.getCurrentFocusPlan?.() || null, false);
    try {
      const blob = await buildFullReportPdfBlob(sections);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'Full_Report.pdf';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } finally {
      document.body.classList.remove('print-export');
      document.body.classList.remove('export-wide');
      toggleExportHiders(false);
      window.setCaregiverNotesExportMode?.(false);
      window.exportDateRange = null;
      if (cgStart) cgStart.value = previousRange.start;
      if (cgEnd) cgEnd.value = previousRange.end;
      api.applyCaregiverFilters?.();
      await api.renderMoodSection?.();
    }
  }

  async function shareFullReportPdf() {
    const sections = [...document.querySelectorAll('[data-print-section]')];
    if (!sections.length) {
      alert('No printable sections found.');
      return;
    }
    const exportRange = await getExportRangeSelection();
    if (!exportRange) return;
    toggleExportHiders(true);
    document.body.classList.add('print-export');
    document.body.classList.add('export-wide');
    window.setCaregiverNotesExportMode?.(true);
    const api = window.caregiverReportApi || {};
    const cgStart = api.cgInputs?.start || document.getElementById('cgStart');
    const cgEnd = api.cgInputs?.end || document.getElementById('cgEnd');
    const previousRange = { start: cgStart?.value || '', end: cgEnd?.value || '' };
    window.exportDateRange = exportRange;
    if (cgStart) cgStart.value = exportRange.startInput;
    if (cgEnd) cgEnd.value = exportRange.endInput;
    api.applyCaregiverFilters?.();
    await api.renderMoodSection?.();
    api.updateFocusPdfSummary?.(api.getCurrentFocusPlan?.() || null, false);
    try {
      const blob = await buildFullReportPdfBlob(sections);
      const fileName = 'Full_Report.pdf';
      const file = new File([blob], fileName, { type: 'application/pdf' });
      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        await navigator.share({ files: [file], title: 'Full Report' });
      } else {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
    } catch (error) {
      console.error('Share full report failed', error);
      alert('Unable to share the PDF right now.');
    } finally {
      document.body.classList.remove('print-export');
      document.body.classList.remove('export-wide');
      toggleExportHiders(false);
      window.setCaregiverNotesExportMode?.(false);
      window.exportDateRange = null;
      if (cgStart) cgStart.value = previousRange.start;
      if (cgEnd) cgEnd.value = previousRange.end;
      api.applyCaregiverFilters?.();
      await api.renderMoodSection?.();
    }
  }

  async function printFullReport() {
    const exportRange = await getExportRangeSelection();
    if (!exportRange) return;
    toggleExportHiders(true);
    document.body.classList.add('print-export');
    document.body.classList.add('export-wide');
    window.setCaregiverNotesExportMode?.(true);
    const api = window.caregiverReportApi || {};
    const cgStart = api.cgInputs?.start || document.getElementById('cgStart');
    const cgEnd = api.cgInputs?.end || document.getElementById('cgEnd');
    const previousRange = { start: cgStart?.value || '', end: cgEnd?.value || '' };
    window.exportDateRange = exportRange;
    if (cgStart) cgStart.value = exportRange.startInput;
    if (cgEnd) cgEnd.value = exportRange.endInput;
    api.applyCaregiverFilters?.();
    await api.renderMoodSection?.();

    const restore = async () => {
      document.body.classList.remove('print-export');
      document.body.classList.remove('export-wide');
      toggleExportHiders(false);
      window.setCaregiverNotesExportMode?.(false);
      window.exportDateRange = null;
      if (cgStart) cgStart.value = previousRange.start;
      if (cgEnd) cgEnd.value = previousRange.end;
      api.applyCaregiverFilters?.();
      await api.renderMoodSection?.();
      window.removeEventListener('afterprint', restore);
    };
    window.addEventListener('afterprint', restore);
    window.print();
  }

  async function printCalendarOnly() {
    toggleExportHiders(true);
    document.body.classList.add('print-export');
    document.body.classList.add('calendar-print-only');
    const restore = () => {
      document.body.classList.remove('print-export');
      document.body.classList.remove('calendar-print-only');
      toggleExportHiders(false);
      window.removeEventListener('afterprint', restore);
    };
    window.addEventListener('afterprint', restore);
    window.print();
  }

  async function exportCalendarPdf(share = false) {
    const target = document.getElementById('hc-root');
    if (!target) return;
    toggleExportHiders(true);
    document.body.classList.add('print-export');
    document.body.classList.add('calendar-print-only');
    try {
      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
      const canvas = await html2canvas(target, { scale: 2, backgroundColor: '#ffffff' });
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ unit: 'pt', format: 'a4' });
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const margin = 28;
      const imgW = pageW - margin * 2;
      const imgH = canvas.height * (imgW / canvas.width);
      const finalH = Math.min(imgH, pageH - margin * 2);
      const finalW = imgH > finalH ? finalH * (canvas.width / canvas.height) : imgW;
      const x = (pageW - finalW) / 2;
      pdf.addImage(canvas.toDataURL('image/png'), 'PNG', x, margin, finalW, finalH);
      const blob = pdf.output('blob');
      const fileName = 'Calendar.pdf';
      if (share && navigator.canShare) {
        const file = new File([blob], fileName, { type: 'application/pdf' });
        if (navigator.canShare({ files: [file] })) {
          await navigator.share({ files: [file], title: 'Calendar' });
          return;
        }
      }
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } finally {
      document.body.classList.remove('print-export');
      document.body.classList.remove('calendar-print-only');
      toggleExportHiders(false);
    }
  }

  document.getElementById('fullExportBtn')?.addEventListener('click', exportFullReportPDF);
  document.getElementById('fullShareBtn')?.addEventListener('click', shareFullReportPdf);
  document.getElementById('fullPrintBtn')?.addEventListener('click', printFullReport);
  document.getElementById('calendarPrintBtn')?.addEventListener('click', printCalendarOnly);
  document.getElementById('hcPrintBtn')?.addEventListener('click', printCalendarOnly);
  document.getElementById('hcShareBtn')?.addEventListener('click', () => exportCalendarPdf(true));

  function getExportRangeDefaults() {
    const api = window.caregiverReportApi || {};
    const startVal = api.cgInputs?.start?.value || '';
    const endVal = api.cgInputs?.end?.value || '';
    const today = new Date();
    const fallbackEnd = api.formatDateInputValue ? api.formatDateInputValue(today) : '';
    return {
      start: startVal || '',
      end: endVal || fallbackEnd
    };
  }

  function openExportRangeModal() {
    return new Promise((resolve) => {
      const overlay = document.getElementById('exportRangeOverlay');
      const startInput = document.getElementById('exportRangeStart');
      const endInput = document.getElementById('exportRangeEnd');
      const closeBtn = document.getElementById('exportRangeClose');
      const cancelBtn = document.getElementById('exportRangeCancel');
      const applyBtn = document.getElementById('exportRangeApply');
      if (!overlay || !startInput || !endInput || !applyBtn) {
        resolve(null);
        return;
      }
      const defaults = getExportRangeDefaults();
      startInput.value = defaults.start || '';
      endInput.value = defaults.end || '';

      const cleanup = () => {
        overlay.classList.add('is-hidden');
        closeBtn?.removeEventListener('click', onCancel);
        cancelBtn?.removeEventListener('click', onCancel);
        applyBtn.removeEventListener('click', onApply);
        overlay.removeEventListener('click', onOverlay);
      };

      const onCancel = () => {
        cleanup();
        resolve(null);
      };

      const onApply = () => {
        const startVal = startInput.value;
        const endVal = endInput.value;
        if (!startVal || !endVal) {
          alert('Pick a start and end date for the export.');
          return;
        }
        const api = window.caregiverReportApi || {};
        const start = api.parseCaregiverDate?.(`${startVal}T00:00`);
        const end = api.parseCaregiverDate?.(`${endVal}T23:59`);
        if (!start || !end || start > end) {
          alert('Please choose a valid date range.');
          return;
        }
        cleanup();
        resolve({
          start,
          end,
          startInput: startVal,
          endInput: endVal
        });
      };

      const onOverlay = (event) => {
        if (event.target === overlay) onCancel();
      };

      closeBtn?.addEventListener('click', onCancel);
      cancelBtn?.addEventListener('click', onCancel);
      applyBtn.addEventListener('click', onApply);
      overlay.addEventListener('click', onOverlay);
      overlay.classList.remove('is-hidden');
    });
  }

  async function getExportRangeSelection() {
    return await openExportRangeModal();
  }
</script>

<script>
  (function(){
    const version = window.STAR_BUILD_VERSION || '2025.01.09E';
    if (!window.STAR_BUILD_VERSION) window.STAR_BUILD_VERSION = version;
    const ensureBadge = () => {
      if (document.getElementById('star-build-version')) return;
      const badge = document.createElement('div');
      badge.id = 'star-build-version';
      badge.textContent = `Build ${version}`;
      badge.style.cssText = `
        position:fixed;
        right:12px;
        bottom:12px;
        background:rgba(17,17,17,0.85);
        color:#f9fafb;
        font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
        font-size:11px;
        font-weight:600;
        letter-spacing:0.02em;
        padding:6px 10px;
        border-radius:10px;
        box-shadow:0 6px 18px rgba(0,0,0,0.18);
        z-index:998;
        pointer-events:none;
      `;
      document.body.appendChild(badge);
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', ensureBadge, { once: true });
    } else {
      ensureBadge();
    }
  })();
</script>

<script type="module">
import { rest, getSessionFromStorage } from './restClient.js?v=2025.01.09E';

(() => {
  // Bail out quietly if the calendar HTML isn't present
  const root  = document.getElementById('hc-root');
  const grid  = document.getElementById('hc-grid');
  const title = document.getElementById('hc-monthTitle');
  if (!root || !grid || !title) return;

  const kvBm   = document.getElementById('hc-kv-bm');
  const kvSlp  = document.getElementById('hc-kv-sleep');
  const kvSlpLow = document.getElementById('hc-kv-sleep-low');
  const kvOnst = document.getElementById('hc-kv-onset');
  const kvNight = document.getElementById('hc-kv-night');
  const kvPrnSleep = document.getElementById('hc-kv-prn-sleep');
  const kvPrnMania = document.getElementById('hc-kv-prn-mania');
  const kvPrnAggr = document.getElementById('hc-kv-prn-aggr');
  const kvTired = document.getElementById('hc-kv-tired');
  const kvMan  = document.getElementById('hc-kv-manic');
  const kvSick = document.getElementById('hc-kv-sick');
  const kvTemp = document.getElementById('hc-kv-temp');
  const kvMedChange = document.getElementById('hc-kv-med-change');
  const kvApp  = document.getElementById('hc-kv-appetite');
  const kvMoon = document.getElementById('hc-kv-moon');
  const kvAno  = document.getElementById('hc-kv-anomaly');

  const quickLookList = document.getElementById('calendarQuickLookList');
  const quickLookMonth = document.getElementById('calendarQuickLookMonth');
  const quickLookEmpty = document.getElementById('calendarQuickLookEmpty');
  const monthlyShiftList = document.getElementById('monthlyShiftList');
  const monthlyShiftMonths = document.getElementById('monthlyShiftMonths');
  const monthlyShiftEmpty = document.getElementById('monthlyShiftEmpty');

  const editorOverlay   = document.getElementById('hc-editor-overlay');
  const editorForm      = document.getElementById('hcEditorForm');
  const editorDateLabel = document.getElementById('hcEditorDate');
  const editorQuick     = document.getElementById('hcEditorQuickTag');
  const editorSleep     = document.getElementById('hcEditorSleepHours');
  const editorNotes     = document.getElementById('hcEditorNotes');
  const editorCancelBtn = document.getElementById('hcEditorCancel');
  let editorDateKey = null;

  function $(s){ return document.querySelector(s); }
  function pad(n){ return String(n).padStart(2,'0'); }
  const sessionInfo = getSessionFromStorage?.();
  const CURRENT_USER_ID = sessionInfo?.user?.id || null;
  const GROUP_STORAGE_KEY = 'currentGroupId';
  const LOCAL_HEALTH_KEY = 'healthCalendarAnnotations';
  const HEALTH_LAST_SAVED_KEY = 'healthCalendarLastSavedAt';
  let LOCAL_HEALTH = {};
  try { LOCAL_HEALTH = JSON.parse(localStorage.getItem(LOCAL_HEALTH_KEY) || '{}'); } catch { LOCAL_HEALTH = {}; }

  function parseSleepOnset(value){
    if (value == null || value === '') return null;
    if (typeof value === 'boolean') return value ? 180 : 0;
    if (typeof value === 'number' && Number.isFinite(value)) return value;
    const str = String(value).toLowerCase();
    if (!str) return null;

    if (/under\s*30|<\s*30/.test(str)) return 20;
    if (/30(?:\s*[-â€“]\s*60)?/.test(str)) return 45;
    if (/60(?:\s*[-â€“]\s*120)?|1-2|one to two/.test(str)) return 90;
    if (/120(?:\s*[-â€“]\s*180)?|2-3|two to three/.test(str)) return 150;
    if (/180|3\+|over 3|three plus/.test(str)) return 210;

    const hours = str.match(/(\d+(?:\.\d+)?)\s*(?:h|hour)/);
    if (hours) return Math.round(parseFloat(hours[1]) * 60);
    const minutes = str.match(/(\d+(?:\.\d+)?)\s*(?:m|min)/);
    if (minutes) return Math.round(parseFloat(minutes[1]));

    return null;
  }

  async function ensureGroupId(){
    let gid = localStorage.getItem(GROUP_STORAGE_KEY);
    if (gid) return gid;
    if (!CURRENT_USER_ID) return null;
    try{
      const rows = await rest([
        'group_members?select=group_id',
        `user_id=eq.${encodeURIComponent(CURRENT_USER_ID)}`,
        'order=joined_at.asc',
        'limit=1'
      ].join('&'));
      gid = rows?.[0]?.group_id || null;
      if (gid) {
        try { localStorage.setItem(GROUP_STORAGE_KEY, gid); } catch {}
      }
      return gid;
    } catch (error){
      console.warn('ensureGroupId error', error?.message || error);
      return null;
    }
  }

  function hasLateSleepOnset(source){
    if (!source) return false;
    const direct = source.sleep_onset_difficulty ?? source.difficulty_sleep_onset ?? null;
    if (typeof direct === 'boolean') return direct;
    if (typeof direct === 'string') {
      const norm = direct.trim().toLowerCase();
      if (['yes','true','y','1','late','on','ğŸ¦‰'].includes(norm)) return true;
      if (['no','false','n','0','off'].includes(norm)) return false;
    }
    const mins = parseSleepOnset(
      source.sleep_onset_duration ??
      source.sleep_onset_minutes ??
      source.sleep_onset ??
      source.sleep_latency ??
      source.sleep_latency_minutes
    );
    return mins != null && mins >= 120;
  }
  function hasAppetiteChange(source){
    if (!source) return false;
    const candidates = [
      source.appetite_change_flag,
      source.appetite_change,
      source.appetite,
      source.appetite_change,
      source.change_in_appetite,
      source.appetite_flag,
      source.behavior_appetite,
      source.appetite_notes
    ];
    for (const value of candidates) {
      if (typeof value === 'boolean') return value;
      if (typeof value === 'number') return value !== 0;
      if (typeof value === 'string') {
        const norm = value.trim().toLowerCase();
        if (!norm) continue;
        if (['yes','y','true','1','less','more','low','high','off','reduced','increase','decrease'].some(token => norm.includes(token))) {
          if (norm.includes('no change') || norm === 'normal') continue;
          return true;
        }
      }
    }
    return false;
  }
  const EMO = { bm:'ğŸ’©', sleep:'ğŸ˜´', sleep_low:'ğŸ˜ª', onset:'ğŸ¦‰', night:'ğŸŒ™', prn_sleep:'ğŸ’ŠS', prn_mania:'ğŸ’ŠM', prn_aggr:'ğŸ’ŠA', tired:'ğŸ¥±', manic:'âš¡ï¸', sick:'ğŸ¤’', temp:'ğŸŒ¡ï¸', med_change:'ğŸ“âœï¸', appetite:'ğŸ½ï¸', moon:'ğŸŒ•', anomaly:'ğŸš©' };
  const QUICK_LOOK_ITEMS = [
    { key:'moon', label:'Full moon', emoji:EMO.moon },
    { key:'sleep', label:'Good sleep', emoji:EMO.sleep },
    { key:'onset', label:'Late onset', emoji:EMO.onset },
    { key:'prn_sleep', label:'S PRN sleep', emoji:EMO.prn_sleep },
    { key:'manic', label:'Manic', emoji:EMO.manic },
    { key:'appetite', label:'Appetite change', emoji:EMO.appetite },
    { key:'med_change', label:'Med change', emoji:EMO.med_change }
  ];
  const SHIFT_METRICS = [
    { key:'bm', label:'BM', emoji:EMO.bm },
    { key:'sick', label:'Sick', emoji:EMO.sick },
    { key:'onset', label:'Late onset', emoji:EMO.onset },
    { key:'sleep', label:'Good sleep', emoji:EMO.sleep },
    { key:'appetite', label:'Appetite change', emoji:EMO.appetite },
    { key:'prn_sleep', label:'S PRN sleep', emoji:EMO.prn_sleep },
    { key:'med_change', label:'Med change', emoji:EMO.med_change }
  ];

  function saveLocalHealth(){
    try { localStorage.setItem(LOCAL_HEALTH_KEY, JSON.stringify(LOCAL_HEALTH)); } catch {}
    stampHealthUpdate();
  }

  function stampHealthUpdate(){
    try { localStorage.setItem(HEALTH_LAST_SAVED_KEY, String(Date.now())); } catch {}
  }

  function applyHealthFlagToMap(key, data = {}){
    const base = MAP[key] || { bm:false, sleep:null, sleep_low:false, onset:false, night:false, prn_sleep:false, prn_mania:false, prn_aggr:false, tired:false, manic:false, sick:false, temp:false, med_change:false, appetite:false, moon:false, anomaly:false };
    const hours = data.sleepHours != null ? Number(data.sleepHours) : (data.sleep ? 8 : null);
    const sleepLowFromHours = Number.isFinite(hours) ? hours < 8 : null;
    MAP[key] = {
      bm: base.bm || !!data.bm,
      sleep: hours != null ? Math.max(base.sleep ?? 0, hours) : base.sleep,
      sleep_low: (sleepLowFromHours === true)
        ? true
        : (sleepLowFromHours === false)
        ? false
        : (base.sleep_low || !!data.sleep_low),
      onset: base.onset || !!data.onset,
      night: base.night || !!data.night,
      prn_sleep: base.prn_sleep || !!data.prn_sleep,
      prn_mania: base.prn_mania || !!data.prn_mania,
      prn_aggr: base.prn_aggr || !!data.prn_aggr,
      tired: base.tired || !!data.tired,
      manic: base.manic || !!data.manic,
      sick: base.sick || !!data.sick,
      temp: base.temp || !!data.temp,
      med_change: base.med_change || !!data.med_change,
      appetite: base.appetite || !!data.appetite,
      moon: base.moon || !!data.moon,
      anomaly: base.anomaly || !!data.anomaly
    };
  }

  let Y = (new Date()).getFullYear();
  let M = (new Date()).getMonth(); // 0-11
  let MAP = {};
  let EVENT_MAP = {};              // meetings/appointments
  let HEALTH_FLAGS = {};           // persisted manual flags
  const FORCE_CALENDAR_DEMO = true;
  const layers = { bm:true, sleep:true, sleep_low:true, onset:true, night:true, prn_sleep:true, prn_mania:true, prn_aggr:true, tired:true, manic:true, sick:true, temp:true, med_change:true, appetite:true, moon:true, anomaly:true };
  const SYNODIC_MONTH = 29.530588853; // days
  const BASE_FULL_MOON = Date.UTC(2024, 8, 17, 18, 34); // Sep 17 2024 full moon reference

  const isFullMoonKey = (key) => {
    const dt = new Date(`${key}T00:00:00Z`);
    if (Number.isNaN(dt)) return false;
    const diffDays = (dt.getTime() - BASE_FULL_MOON) / 86400000;
    const phase = ((diffDays % SYNODIC_MONTH) + SYNODIC_MONTH) % SYNODIC_MONTH;
    return phase < 1 || phase > SYNODIC_MONTH - 1;
  };

  function fmtMonth(y,m){ return new Date(y,m,1).toLocaleString(undefined,{month:'long',year:'numeric'}); }
  function monthBoundsUTC(y,m){
    const start = new Date(Date.UTC(y, m, 1)).toISOString();
    const end   = new Date(Date.UTC(m===11?y+1:y, (m+1)%12, 1)).toISOString();
    return { start, end };
  }
  const humanDate = (key) => {
    const dt = new Date(key);
    return Number.isNaN(dt.getTime()) ? key : dt.toLocaleDateString(undefined, { weekday:'short', month:'short', day:'numeric' });
  };

  function seedHealthCalendarDemo(y, m){
    const demo = {};
    const add = (day, flags) => {
      const key = `${y}-${pad(m + 1)}-${pad(day)}`;
      demo[key] = {
        bm: !!flags.bm,
        sleep: flags.sleep ?? null,
        sleep_low: !!flags.sleep_low,
        onset: !!flags.onset,
        night: !!flags.night,
        prn_sleep: !!flags.prn_sleep,
        prn_mania: !!flags.prn_mania,
        prn_aggr: !!flags.prn_aggr,
        tired: !!flags.tired,
        manic: !!flags.manic,
        sick: !!flags.sick,
        temp: !!flags.temp,
        med_change: !!flags.med_change,
        appetite: !!flags.appetite,
        moon: !!flags.moon,
        anomaly: !!flags.anomaly
      };
    };
    add(1,  { moon:true });
    add(2,  { appetite:true, bm:true });
    add(3,  { sleep:8, night:true });
    add(4,  { sleep_low:true, tired:true });
    add(6,  { prn_sleep:true, sleep:8 });
    add(7,  { sick:true, temp:true });
    add(9,  { bm:true, appetite:true });
    add(11, { onset:true, night:true });
    add(13, { prn_mania:true, manic:true });
    add(14, { prn_aggr:true, anomaly:true });
    add(16, { sleep:8, bm:true });
    add(18, { sleep_low:true, tired:true });
    add(20, { appetite:true, temp:true, med_change:true });
    add(22, { night:true, prn_sleep:true });
    add(24, { onset:true, sleep:8 });
    add(26, { sick:true, temp:true, med_change:true });
    add(27, { appetite:true, bm:true });
    return demo;
  }

  function renderCalendarQuickLook(counts){
    if (!quickLookList) return;
    const monthLabel = fmtMonth(Y, M);
    if (quickLookMonth) quickLookMonth.textContent = monthLabel;
    quickLookList.innerHTML = '';
    QUICK_LOOK_ITEMS.forEach(item => {
      const li = document.createElement('li');
      li.className = 'calendar-quick-item';
      const label = document.createElement('div');
      label.className = 'calendar-quick-label';
      const emoji = document.createElement('span');
      emoji.className = 'calendar-quick-emoji';
      emoji.textContent = item.emoji;
      const text = document.createElement('span');
      text.textContent = item.label;
      label.appendChild(emoji);
      label.appendChild(text);
      const count = document.createElement('span');
      count.className = 'calendar-quick-count';
      count.textContent = String(counts[item.key] ?? 0);
      li.appendChild(label);
      li.appendChild(count);
      quickLookList.appendChild(li);
    });
    const hasData = QUICK_LOOK_ITEMS.some(item => (counts[item.key] ?? 0) > 0);
    if (quickLookEmpty) quickLookEmpty.classList.toggle('is-hidden', hasData);
  }

  function normalizeHealthPayload(payload){
    if (!payload || typeof payload !== 'object') return {};
    const sleepHoursVal = Number.isFinite(Number(payload.sleepHours)) ? Number(payload.sleepHours) : null;
    const goodSleep = payload.sleep === true || (sleepHoursVal != null && sleepHoursVal >= 8);
    const poorSleep = payload.sleep_low === true || (sleepHoursVal != null && sleepHoursVal < 8);
    return {
      bm: !!payload.bm,
      sleep: goodSleep,
      sleep_low: poorSleep,
      onset: !!payload.onset,
      night: !!payload.night,
      prn_sleep: !!payload.prn_sleep,
      prn_mania: !!payload.prn_mania,
      prn_aggr: !!payload.prn_aggr,
      tired: !!payload.tired,
      manic: !!payload.manic,
      sick: !!payload.sick,
      temp: !!payload.temp,
      med_change: !!payload.med_change,
      appetite: !!payload.appetite,
      moon: !!payload.moon,
      anomaly: !!payload.anomaly
    };
  }

  function toDateKeyUTC(date){
    return date.toISOString().slice(0,10);
  }

  function buildEmptyCounts(){
    return { bm:0, sleep:0, sleep_low:0, onset:0, night:0, prn_sleep:0, prn_mania:0, prn_aggr:0, tired:0, manic:0, sick:0, temp:0, med_change:0, appetite:0, moon:0, anomaly:0 };
  }

  function countFlagsInRange(map, startDate, endDate){
    const counts = buildEmptyCounts();
    const startKey = toDateKeyUTC(startDate);
    const endKey = toDateKeyUTC(endDate);
    Object.entries(map).forEach(([key, flags]) => {
      if (key < startKey || key >= endKey) return;
      Object.keys(counts).forEach(flagKey => {
        if (flags?.[flagKey]) counts[flagKey] += 1;
      });
    });
    return counts;
  }

  function renderMonthlyShiftCard(titleText, deltas){
    const card = document.createElement('div');
    card.className = 'monthly-shift-card';
    const titleEl = document.createElement('div');
    titleEl.className = 'monthly-shift-title';
    titleEl.textContent = titleText;
    card.appendChild(titleEl);
    deltas.forEach(delta => {
      const row = document.createElement('div');
      row.className = 'monthly-shift-row';
      const label = document.createElement('div');
      label.textContent = `${delta.emoji} ${delta.label}`;
      const value = document.createElement('div');
      value.className = `delta ${delta.value >= 0 ? 'pos' : 'neg'}`;
      value.textContent = `${delta.value >= 0 ? '+' : ''}${delta.value}`;
      row.appendChild(label);
      row.appendChild(value);
      card.appendChild(row);
    });
    return card;
  }

  function buildShiftDeltas(currentCounts, previousCounts){
    return SHIFT_METRICS.map(metric => ({
      key: metric.key,
      label: metric.label,
      emoji: metric.emoji,
      value: (currentCounts[metric.key] || 0) - (previousCounts[metric.key] || 0)
    }))
      .filter(delta => delta.value !== 0)
      .sort((a, b) => Math.abs(b.value) - Math.abs(a.value))
      .slice(0, 3);
  }

  async function fetchHealthFlagMap(startDate, endDate){
    const map = {};
    const startKey = toDateKeyUTC(startDate);
    const endKey = toDateKeyUTC(endDate);
    const addFlags = (dateKey, payload) => {
      if (!dateKey) return;
      const normalized = normalizeHealthPayload(payload);
      if (!map[dateKey]) map[dateKey] = {};
      Object.keys(normalized).forEach(key => {
        if (normalized[key]) map[dateKey][key] = true;
      });
    };

    const groupId = await ensureGroupId();
    if (groupId) {
      try{
        const params = [
          'calendar_events?select=id,type,title,start_date,notes',
          `group_id=eq.${encodeURIComponent(groupId)}`,
          `start_date=gte.${encodeURIComponent(startKey)}`,
          `start_date=lt.${encodeURIComponent(endKey)}`,
          'order=start_date.asc'
        ];
        const rows = await rest(params.join('&'));
        (rows || []).forEach(evt => {
          const isHealthFlag = evt.type === 'health-flag' || (evt.type === 'other' && /^Health:/i.test(evt.title || ''));
          if (!isHealthFlag) return;
          let payload = {};
          try { payload = JSON.parse(evt.notes || '{}'); } catch {}
          addFlags(evt.start_date, payload);
        });
      } catch (error) {
        console.warn('monthly shifts calendar events error', error?.message || error);
      }
    } else {
      Object.entries(LOCAL_HEALTH || {}).forEach(([key, payload]) => {
        if (key >= startKey && key < endKey) addFlags(key, payload || {});
      });
    }

    return map;
  }

  async function updateMonthlyShifts(){
    if (!monthlyShiftList) return;
    const now = new Date();
    const currentStart = new Date(Date.UTC(now.getFullYear(), now.getMonth(), 1));
    const lastFullStart = new Date(Date.UTC(now.getFullYear(), now.getMonth() - 1, 1));
    const secondFullStart = new Date(Date.UTC(now.getFullYear(), now.getMonth() - 2, 1));
    const thirdFullStart = new Date(Date.UTC(now.getFullYear(), now.getMonth() - 3, 1));
    const nextMonthStart = new Date(Date.UTC(now.getFullYear(), now.getMonth() + 1, 1));

    const fullMonthsLabel = [
      fmtMonth(thirdFullStart.getUTCFullYear(), thirdFullStart.getUTCMonth()),
      fmtMonth(secondFullStart.getUTCFullYear(), secondFullStart.getUTCMonth()),
      fmtMonth(lastFullStart.getUTCFullYear(), lastFullStart.getUTCMonth())
    ].join(' \u2192 ');
    if (monthlyShiftMonths) monthlyShiftMonths.textContent = fullMonthsLabel;

    const map = await fetchHealthFlagMap(thirdFullStart, nextMonthStart);
    const hasAny = Object.keys(map).length > 0;

    const lastFullEnd = new Date(Date.UTC(lastFullStart.getUTCFullYear(), lastFullStart.getUTCMonth() + 1, 1));
    const secondFullEnd = new Date(Date.UTC(secondFullStart.getUTCFullYear(), secondFullStart.getUTCMonth() + 1, 1));
    const thirdFullEnd = new Date(Date.UTC(thirdFullStart.getUTCFullYear(), thirdFullStart.getUTCMonth() + 1, 1));
    const todayUtc = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate() + 1));
    const lastMonthDays = new Date(Date.UTC(lastFullStart.getUTCFullYear(), lastFullStart.getUTCMonth() + 1, 0)).getUTCDate();
    const dayCount = Math.min(now.getDate(), lastMonthDays);
    const lastMonthSameDaysEnd = new Date(Date.UTC(lastFullStart.getUTCFullYear(), lastFullStart.getUTCMonth(), dayCount + 1));

    monthlyShiftList.innerHTML = '';

    let demoFallback = false;
    if (!hasAny) {
      demoFallback = true;
    }

    const comparisons = [];
    if (!demoFallback) {
      const decVsNov = buildShiftDeltas(
        countFlagsInRange(map, secondFullStart, secondFullEnd),
        countFlagsInRange(map, thirdFullStart, thirdFullEnd)
      );
      const janVsDec = buildShiftDeltas(
        countFlagsInRange(map, lastFullStart, lastFullEnd),
        countFlagsInRange(map, secondFullStart, secondFullEnd)
      );
      const currentVsLast = buildShiftDeltas(
        countFlagsInRange(map, currentStart, todayUtc),
        countFlagsInRange(map, lastFullStart, lastMonthSameDaysEnd)
      );
      comparisons.push({
        title: `${fmtMonth(secondFullStart.getUTCFullYear(), secondFullStart.getUTCMonth())} vs ${fmtMonth(thirdFullStart.getUTCFullYear(), thirdFullStart.getUTCMonth())}`,
        deltas: decVsNov
      });
      comparisons.push({
        title: `${fmtMonth(lastFullStart.getUTCFullYear(), lastFullStart.getUTCMonth())} vs ${fmtMonth(secondFullStart.getUTCFullYear(), secondFullStart.getUTCMonth())}`,
        deltas: janVsDec
      });
      comparisons.push({
        title: `${fmtMonth(currentStart.getUTCFullYear(), currentStart.getUTCMonth())} to-date vs ${fmtMonth(lastFullStart.getUTCFullYear(), lastFullStart.getUTCMonth())} (same days)`,
        deltas: currentVsLast
      });
    } else {
      comparisons.push({
        title: `${fmtMonth(secondFullStart.getUTCFullYear(), secondFullStart.getUTCMonth())} vs ${fmtMonth(thirdFullStart.getUTCFullYear(), thirdFullStart.getUTCMonth())}`,
        deltas: [
          { label:'Sick', emoji:EMO.sick, value:6 },
          { label:'BM', emoji:EMO.bm, value:-5 },
          { label:'Late onset', emoji:EMO.onset, value:-5 }
        ]
      });
      comparisons.push({
        title: `${fmtMonth(lastFullStart.getUTCFullYear(), lastFullStart.getUTCMonth())} vs ${fmtMonth(secondFullStart.getUTCFullYear(), secondFullStart.getUTCMonth())}`,
        deltas: [
          { label:'BM', emoji:EMO.bm, value:13 },
          { label:'Good sleep', emoji:EMO.sleep, value:13 },
          { label:'Appetite change', emoji:EMO.appetite, value:9 }
        ]
      });
      comparisons.push({
        title: `${fmtMonth(currentStart.getUTCFullYear(), currentStart.getUTCMonth())} to-date vs ${fmtMonth(lastFullStart.getUTCFullYear(), lastFullStart.getUTCMonth())} (same days)`,
        deltas: [
          { label:'BM', emoji:EMO.bm, value:-1 },
          { label:'Late onset', emoji:EMO.onset, value:1 },
          { label:'S PRN sleep', emoji:EMO.prn_sleep, value:1 }
        ]
      });
    }

    const hasDeltas = comparisons.some(c => c.deltas && c.deltas.length);
    comparisons.forEach(comp => {
      if (!comp.deltas || !comp.deltas.length) return;
      monthlyShiftList.appendChild(renderMonthlyShiftCard(comp.title, comp.deltas));
    });
    if (monthlyShiftEmpty) monthlyShiftEmpty.classList.toggle('is-hidden', hasDeltas);
  }

  function render(){
    if (!grid || !title) return;

    title.textContent = fmtMonth(Y, M);
    grid.innerHTML = '';
    ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'].forEach(d=>{
      const el=document.createElement('div'); el.className='hc-dow'; el.textContent=d; grid.appendChild(el);
    });

    const first = new Date(Y, M, 1);
    const last  = new Date(Y, M+1, 0);
    const startPad = first.getDay();
    for(let i=0;i<startPad;i++){ const b=document.createElement('div'); b.className='hc-cell'; grid.appendChild(b); }

  let bmDays=0, sleepDays=0, sleepLowDays=0, onsetDays=0, nightDays=0, prnSleepDays=0, prnManiaDays=0, prnAggrDays=0, tiredDays=0, manicDays=0, sickDays=0, tempDays=0, medChangeDays=0, appetiteDays=0, moonDays=0, anomalyDays=0;

    for(let day=1; day<=last.getDate(); day++){
      const cell = document.createElement('div'); cell.className='hc-cell'; cell.setAttribute('role','gridcell');
      const key = Y + '-' + pad(M+1) + '-' + pad(day);
      const rec = MAP[key] || { bm:false, sleep:null, sleep_low:false, onset:false, night:false, prn_sleep:false, prn_mania:false, prn_aggr:false, tired:false, manic:false, sick:false, temp:false, med_change:false, appetite:false, moon:false, anomaly:false };
      const moonToday = isFullMoonKey(key);
      if (!rec.moon && moonToday) {
        rec.moon = true;
        MAP[key] = { ...rec };
      }
      cell.dataset.date = key;

      const head = document.createElement('div'); head.className='hc-date'; head.textContent = day; cell.appendChild(head);

      const icons = document.createElement('div'); icons.className='hc-icons';
      if (rec.bm    && layers.bm   ){ const s=document.createElement('span'); s.textContent=EMO.bm;    s.setAttribute('aria-label','BM'); icons.appendChild(s); bmDays++; }
      const hasSleepHours = rec.sleep != null;
      const goodSleep = hasSleepHours ? rec.sleep >= 8 : false;
      const poorSleep = hasSleepHours ? rec.sleep < 8 : !!rec.sleep_low;
      if (goodSleep && layers.sleep){ const s=document.createElement('span'); s.textContent=EMO.sleep; s.setAttribute('aria-label','Good sleep (8+ hours)'); icons.appendChild(s); sleepDays++; }
      if (poorSleep && layers.sleep_low){ const s=document.createElement('span'); s.textContent=EMO.sleep_low; s.setAttribute('aria-label','Poor sleep (< 8 hours)'); icons.appendChild(s); sleepLowDays++; }
      if (rec.onset && layers.onset){ const s=document.createElement('span'); s.textContent=EMO.onset; s.setAttribute('aria-label','Late sleep onset'); icons.appendChild(s); onsetDays++; }
      if (rec.night && layers.night){ const s=document.createElement('span'); s.textContent=EMO.night; s.setAttribute('aria-label','Night waking'); icons.appendChild(s); nightDays++; }
      if (rec.prn_sleep && layers.prn_sleep){ const s=document.createElement('span'); s.textContent=EMO.prn_sleep; s.setAttribute('aria-label','PRN sleep'); icons.appendChild(s); prnSleepDays++; }
      if (rec.prn_mania && layers.prn_mania){ const s=document.createElement('span'); s.textContent=EMO.prn_mania; s.setAttribute('aria-label','PRN mania'); icons.appendChild(s); prnManiaDays++; }
      if (rec.prn_aggr && layers.prn_aggr){ const s=document.createElement('span'); s.textContent=EMO.prn_aggr; s.setAttribute('aria-label','PRN aggression'); icons.appendChild(s); prnAggrDays++; }
      if (rec.tired && layers.tired){ const s=document.createElement('span'); s.textContent=EMO.tired; s.setAttribute('aria-label','Appears tired'); icons.appendChild(s); tiredDays++; }
      if (rec.manic && layers.manic){ const s=document.createElement('span'); s.textContent=EMO.manic; s.setAttribute('aria-label','Manic'); icons.appendChild(s); manicDays++; }
      if (rec.sick  && layers.sick ){ const s=document.createElement('span'); s.textContent=EMO.sick;  s.setAttribute('aria-label','Sick'); icons.appendChild(s); sickDays++; }
      if (rec.temp  && layers.temp ){ const s=document.createElement('span'); s.textContent=EMO.temp;  s.setAttribute('aria-label','Temperature'); icons.appendChild(s); tempDays++; }
      if (rec.med_change && layers.med_change){ const s=document.createElement('span'); s.textContent=EMO.med_change; s.setAttribute('aria-label','Medication change'); icons.appendChild(s); medChangeDays++; }
      if (rec.appetite && layers.appetite){ const s=document.createElement('span'); s.textContent=EMO.appetite; s.setAttribute('aria-label','Change in appetite'); icons.appendChild(s); appetiteDays++; }
      if (rec.moon && layers.moon){ const s=document.createElement('span'); s.textContent=EMO.moon; s.setAttribute('aria-label','Full moon'); icons.appendChild(s); moonDays++; }
      if (rec.anomaly && layers.anomaly){ const s=document.createElement('span'); s.textContent=EMO.anomaly; s.setAttribute('aria-label','Anomaly'); icons.appendChild(s); anomalyDays++; }

      if (icons.children.length) cell.appendChild(icons);
      else { const e=document.createElement('div'); e.className='hc-empty'; e.textContent='â€”'; cell.appendChild(e); }

      const dayEvents = EVENT_MAP[key] || [];
      if (dayEvents.length) {
        const list = document.createElement('div');
        list.className = 'hc-events';
        dayEvents.slice(0,2).forEach(evt => {
          const pill = document.createElement('div');
          pill.className = 'hc-event-pill';
          const timeLabel = evt.all_day ? 'All day' : (evt.start_time || '').slice(0,5) || 'â€”';
          pill.innerHTML = `<strong>${timeLabel}</strong><span>${evt.title || 'Event'}</span>`;
          list.appendChild(pill);
        });
        if (dayEvents.length > 2) {
          const more = document.createElement('div');
          more.className = 'hc-event-pill';
          more.textContent = `+${dayEvents.length - 2} more`;
          list.appendChild(more);
        }
        cell.appendChild(list);
      }

      cell.addEventListener('click', () => openEditor(key));
      grid.appendChild(cell);
    }

    kvBm  && (kvBm.textContent  = 'ğŸ’© BM days: ' + bmDays);
    kvSlp && (kvSlp.textContent = 'ğŸ˜´ GOOD SLEEP (MORE, 8+ hours) days: ' + sleepDays);
    kvSlpLow && (kvSlpLow.textContent = 'ğŸ˜ª Poor sleep (MINUS 8 hours) days: ' + sleepLowDays);
    kvOnst && (kvOnst.textContent = 'ğŸ¦‰ Late sleep onset days: ' + onsetDays);
    kvNight && (kvNight.textContent = 'ğŸŒ™ Night waking days: ' + nightDays);
    kvPrnSleep && (kvPrnSleep.textContent = 'ğŸ’ŠS PRN sleep days: ' + prnSleepDays);
    kvPrnMania && (kvPrnMania.textContent = 'ğŸ’ŠM PRN mania days: ' + prnManiaDays);
    kvPrnAggr && (kvPrnAggr.textContent = 'ğŸ’ŠA PRN aggression days: ' + prnAggrDays);
    kvTired && (kvTired.textContent = 'ğŸ¥± Appears tired days: ' + tiredDays);
    kvMan && (kvMan.textContent = 'âš¡ï¸ Manic days: ' + manicDays);
    kvSick&& (kvSick.textContent= 'ğŸ¤’ Sick days: ' + sickDays);
    kvTemp && (kvTemp.textContent= 'ğŸŒ¡ï¸ Temperature days: ' + tempDays);
    kvMedChange && (kvMedChange.textContent= 'ğŸ“âœï¸ Med change days: ' + medChangeDays);
    kvApp && (kvApp.textContent = 'ğŸ½ï¸ Appetite change days: ' + appetiteDays);
    kvMoon&& (kvMoon.textContent= 'ğŸŒ• Full moon days: ' + moonDays);
    kvAno && (kvAno.textContent = 'ğŸš© Anomaly days: ' + anomalyDays);

    const legendCounts = {
      bm: bmDays,
      sleep: sleepDays,
      sleep_low: sleepLowDays,
      onset: onsetDays,
      night: nightDays,
      prn_sleep: prnSleepDays,
      prn_mania: prnManiaDays,
      prn_aggr: prnAggrDays,
      tired: tiredDays,
      manic: manicDays,
      sick: sickDays,
      temp: tempDays,
      med_change: medChangeDays,
      appetite: appetiteDays,
      moon: moonDays,
      anomaly: anomalyDays
    };
    renderCalendarQuickLook(legendCounts);
  }

  async function loadCaregiverFlags(start, end){
    try{
      const startDate = start.slice(0,10);
      const endDate = end.slice(0,10);
      const params = [
        'caregiver_checkins?select=id,user_id,created_at,submitted_at,date,had_bm,payload',
        `date=gte.${encodeURIComponent(startDate)}`,
        `date=lt.${encodeURIComponent(endDate)}`,
        'order=date.asc'
      ];
      const data = await rest(params.join('&'));
      if (Array.isArray(data)) {
        for (const row of data){
          const dateKey = row.date || '';
          const key = dateKey && /^\d{4}-\d{2}-\d{2}$/.test(dateKey)
            ? dateKey
            : (() => {
                const dt = new Date(row.submitted_at || row.created_at);
                if (Number.isNaN(dt.getTime())) return null;
                return dt.getFullYear() + '-' + pad(dt.getMonth()+1) + '-' + pad(dt.getDate());
              })();
          if (!key) continue;
          const p   = row.payload || {};
          const bm    = (row.had_bm === true) || (/yes/i.test(String(p.bm_today || p.had_bm || '')));
          let   sleep = null;
          const hrsRaw = p.hours_sleep;
          if (typeof hrsRaw === 'string'){
            if (hrsRaw.includes('10')) sleep = 10;
            else { const n = parseFloat(hrsRaw); if (isFinite(n)) sleep = n; }
          } else if (typeof hrsRaw === 'number') { sleep = hrsRaw; }
          const sleepLow = (sleep != null && sleep < 8);
          const onsetLate = hasLateSleepOnset(p) || hasLateSleepOnset(row);
          const nightWake = /yes|true/i.test(String(p.night_wake_flag || p.night_waking || '')) ||
            Number(p.night_wake_count) > 0 ||
            /woke|wake|waking/i.test(String(p.night_wake_notes || ''));
          const prnSleep = /yes|true/i.test(String(p.prn_given || '')) ||
            !!p.prn_name || !!p.prn_time;
          const prnMania = /yes|true/i.test(String(p.prn_mania_given || '')) ||
            !!p.prn_mania_name || !!p.prn_mania_time;
          const prnAggr = /yes|true/i.test(String(p.prn_aggression_given || '')) ||
            !!p.prn_aggression_name || !!p.prn_aggression_time;
          const tired = /yes|true/i.test(String(p.appears_tired || ''));
          const manic = /yes|true/i.test(String(p.manic_flag || p.mania_flag || '')) || ((+p.manic_intensity || 0) > 0);
          const sick  = (p.appears_good_health === false) || /no/i.test(String(p.appears_good_health || ''));
          const temp = p.temp_present === true
            || /yes|true/i.test(String(p.temp_present || ''))
            || !!p.temp_value;
          const appetite = hasAppetiteChange(p) || hasAppetiteChange(row);
          const medChange = p.med_change_present === true
            || /yes|true/i.test(String(p.med_change_present || ''))
            || !!p.med_change_new || !!p.med_change_dose || !!p.med_change_stopped
            || !!p.med_change_prn || !!p.med_change_other
            || !!p.med_change_name || !!p.med_change_details || !!p.med_change_notes;
          const anomaly = p.anomaly_flag === true || /yes/i.test(String(p.anomaly || ''));

          const cur = MAP[key] || { bm:false, sleep:null, sleep_low:false, onset:false, night:false, prn_sleep:false, prn_mania:false, prn_aggr:false, tired:false, manic:false, sick:false, temp:false, med_change:false, appetite:false, moon:false, anomaly:false };
          MAP[key] = {
            bm:    cur.bm    || bm,
            sleep: (sleep!=null && (cur.sleep==null || sleep>cur.sleep)) ? sleep : cur.sleep,
            sleep_low: cur.sleep_low || sleepLow,
            onset: cur.onset || onsetLate,
            night: cur.night || nightWake,
            prn_sleep: cur.prn_sleep || prnSleep,
            prn_mania: cur.prn_mania || prnMania,
            prn_aggr: cur.prn_aggr || prnAggr,
            tired: cur.tired || tired,
            manic: cur.manic || manic,
            sick:  cur.sick  || sick,
            temp:  cur.temp  || temp,
            med_change: cur.med_change || medChange,
            appetite: cur.appetite || appetite,
            moon: cur.moon || isFullMoonKey(key),
            anomaly: cur.anomaly || anomaly
          };
        }
      }
    }catch(error){
      console.warn('caregiver flags load error', error?.message || error);
    }

    if (Object.keys(MAP).length === 0) {
      try{
        const ls = JSON.parse(localStorage.getItem('caregiverEntries') || '[]');
        for (const e of ls){
          const dateKey = e.date || e.entry_date || '';
          let key = null;
          if (dateKey && /^\d{4}-\d{2}-\d{2}$/.test(dateKey)) {
            key = dateKey;
          } else {
            const dt = new Date(e.timestamp || e.created_at || Date.now());
            if (dt < new Date(start) || dt >= new Date(end)) continue;
            key = dt.getFullYear() + '-' + pad(dt.getMonth()+1) + '-' + pad(dt.getDate());
          }
          const bm    = (e.had_bm === true) || (/yes/i.test(String(e.had_bm || e.bm_today || '')));
          const sleep = (typeof e.hours_sleep === 'number') ? e.hours_sleep : null;
          const sleepLow = (sleep != null && sleep < 8);
          const onsetLate = hasLateSleepOnset(e);
          const nightWake = /yes|true/i.test(String(e.night_wake_flag || e.night_waking || '')) ||
            Number(e.night_wake_count) > 0 ||
            /woke|wake|waking/i.test(String(e.night_wake_notes || ''));
          const tired = /yes|true/i.test(String(e.appears_tired || ''));
          const prnSleep = /yes|true/i.test(String(e.prn_given || '')) ||
            !!e.prn_name || !!e.prn_time;
          const prnMania = /yes|true/i.test(String(e.prn_mania_given || '')) ||
            !!e.prn_mania_name || !!e.prn_mania_time;
          const prnAggr = /yes|true/i.test(String(e.prn_aggression_given || '')) ||
            !!e.prn_aggression_name || !!e.prn_aggression_time;
          const manic = /yes|true/i.test(String(e.manic_flag || e.mania_flag || '')) || ((+e.manic_intensity || 0) > 0);
          const sick  = (e.appears_good_health === false) || /no/i.test(String(e.appears_good_health || ''));
          const temp = e.temp_present === true
            || /yes|true/i.test(String(e.temp_present || ''))
            || !!e.temp_value;
          const appetite = hasAppetiteChange(e);
          const medChange = e.med_change_present === true
            || /yes|true/i.test(String(e.med_change_present || ''))
            || !!e.med_change_new || !!e.med_change_dose || !!e.med_change_stopped
            || !!e.med_change_prn || !!e.med_change_other
            || !!e.med_change_name || !!e.med_change_details || !!e.med_change_notes;
          const anomaly = e.anomaly_flag === true || /yes/i.test(String(e.anomaly || ''));
          const cur = MAP[key] || { bm:false, sleep:null, sleep_low:false, onset:false, night:false, prn_sleep:false, prn_mania:false, prn_aggr:false, tired:false, manic:false, sick:false, temp:false, med_change:false, appetite:false, anomaly:false };
          MAP[key] = {
            bm:    cur.bm    || bm,
            sleep: (sleep!=null && (cur.sleep==null || sleep>cur.sleep)) ? sleep : cur.sleep,
            sleep_low: cur.sleep_low || sleepLow,
            onset: cur.onset || onsetLate,
            night: cur.night || nightWake,
            prn_sleep: cur.prn_sleep || prnSleep,
            prn_mania: cur.prn_mania || prnMania,
            prn_aggr: cur.prn_aggr || prnAggr,
            tired: cur.tired || tired,
            manic: cur.manic || manic,
            sick:  cur.sick  || sick,
            temp:  cur.temp  || temp,
            med_change: cur.med_change || medChange,
            appetite: cur.appetite || appetite,
            anomaly: cur.anomaly || anomaly
          };
        }
      }catch(error){
        console.warn('local caregiver flags error', error?.message || error);
      }
    }
  }

  function applyLocalAnnotations(startIso, endIso){
    const start = new Date(startIso);
    const end = new Date(endIso);
    Object.entries(LOCAL_HEALTH).forEach(([key,data])=>{
      const dt = new Date(key);
      if (dt >= start && dt < end) {
        HEALTH_FLAGS[key] = HEALTH_FLAGS[key] || { id:null, data };
        applyHealthFlagToMap(key, data);
      }
    });
  }

  async function loadCalendarEventsInRange(start, end){
    EVENT_MAP = {};
    const groupId = await ensureGroupId();
    if (!groupId) {
      applyLocalAnnotations(start, end);
      return;
    }
    const startDate = start.slice(0,10);
    const endDate = end.slice(0,10);
    try{
      const params = [
        'calendar_events?select=id,title,type,start_date,start_time,all_day,notes,location',
        `group_id=eq.${encodeURIComponent(groupId)}`,
        `start_date=gte.${encodeURIComponent(startDate)}`,
        `start_date=lt.${encodeURIComponent(endDate)}`,
        'order=start_date.asc'
      ];
      const rows = await rest(params.join('&'));
      (rows || []).forEach(evt => {
        const key = evt.start_date;
        if (!key) return;
        const isHealthFlag = evt.type === 'health-flag' || (evt.type === 'other' && /^Health:/i.test(evt.title || ''));
        if (isHealthFlag) {
          let data = {};
          try { data = JSON.parse(evt.notes || '{}'); } catch {}
          HEALTH_FLAGS[key] = { id: evt.id, data };
          applyHealthFlagToMap(key, data);
        } else {
          if (!EVENT_MAP[key]) EVENT_MAP[key] = [];
          EVENT_MAP[key].push(evt);
        }
      });
    } catch (error) {
      console.warn('calendar events error', error?.message || error);
    }
    applyLocalAnnotations(start, end);
  }

  async function loadMonth(){
    MAP = {};
    EVENT_MAP = {};
    HEALTH_FLAGS = {};
    const { start, end } = monthBoundsUTC(Y, M);
    if (FORCE_CALENDAR_DEMO) {
      MAP = seedHealthCalendarDemo(Y, M);
      render();
      updateMonthlyShifts();
      return;
    }
    await loadCaregiverFlags(start, end);
    await loadCalendarEventsInRange(start, end);
    render();
    updateMonthlyShifts();
  }

  function openEditor(dateKey){
    if (!editorOverlay || !editorForm) return;
    editorDateKey = dateKey;
    editorForm.reset();
    const existing = HEALTH_FLAGS[dateKey]?.data || {};
    const rec = MAP[dateKey] || {};
    editorDateLabel.textContent = `Update ${humanDate(dateKey)}`;
    const setBox = (name, value) => {
      const input = editorForm.elements[name];
      if (input) input.checked = !!value;
    };
    setBox('bm', existing.bm ?? rec.bm);
    const hasHours = rec.sleep != null;
    setBox('sleep', existing.sleep ?? (hasHours && rec.sleep >= 8));
    setBox('sleep_low', existing.sleep_low ?? (hasHours && rec.sleep < 8));
    setBox('onset', existing.onset ?? rec.onset);
    setBox('night', existing.night ?? rec.night);
    setBox('prn_sleep', existing.prn_sleep ?? rec.prn_sleep);
    setBox('prn_mania', existing.prn_mania ?? rec.prn_mania);
    setBox('prn_aggr', existing.prn_aggr ?? rec.prn_aggr);
    setBox('tired', existing.tired ?? rec.tired);
    setBox('manic', existing.manic ?? rec.manic);
    setBox('sick', existing.sick ?? rec.sick);
    setBox('temp', existing.temp ?? rec.temp);
    setBox('med_change', existing.med_change ?? rec.med_change);
    setBox('moon', existing.moon ?? rec.moon ?? isFullMoonKey(dateKey));
    setBox('appetite', existing.appetite ?? rec.appetite);
    setBox('anomaly', existing.anomaly ?? rec.anomaly);
    editorSleep.value = existing.sleepHours ?? (rec.sleep ?? '');
    editorNotes.value = existing.note || '';
    if (editorQuick) editorQuick.value = '';
    editorOverlay.classList.remove('is-hidden');
  }

  function closeEditor(){
    editorForm?.reset();
    editorOverlay?.classList.add('is-hidden');
    editorDateKey = null;
  }

    async function saveHealthFlagEntry(dateKey, payload){
      const sleepHoursVal = Number.isFinite(Number(payload.sleepHours)) ? Number(payload.sleepHours) : null;
      const derivedSleep = sleepHoursVal != null ? sleepHoursVal >= 8 : null;
      const derivedSleepLow = sleepHoursVal != null ? sleepHoursVal < 8 : null;
      const normalized = {
        bm: !!payload.bm,
        sleep: derivedSleep !== null ? derivedSleep : !!payload.sleep,
        sleep_low: derivedSleepLow !== null ? derivedSleepLow : !!payload.sleep_low,
        sleepHours: sleepHoursVal,
        onset: !!payload.onset,
        night: !!payload.night,
        prn_sleep: !!payload.prn_sleep,
        prn_mania: !!payload.prn_mania,
        prn_aggr: !!payload.prn_aggr,
        tired: !!payload.tired,
        manic: !!payload.manic,
        sick: !!payload.sick,
        temp: !!payload.temp,
        med_change: !!payload.med_change,
        appetite: !!payload.appetite,
        moon: !!payload.moon,
        anomaly: !!payload.anomaly,
        note: payload.note ? String(payload.note).trim() : null
      };
      const groupId = await ensureGroupId();
      if (!groupId || !CURRENT_USER_ID) {
        LOCAL_HEALTH[dateKey] = normalized;
        saveLocalHealth();
        HEALTH_FLAGS[dateKey] = { id:null, data:normalized };
        applyHealthFlagToMap(dateKey, normalized);
        render();
        updateMonthlyShifts();
        stampHealthUpdate();
        return;
      }

      const summaryBits = [];
      if (normalized.bm) summaryBits.push('BM');
      if (normalized.sleep || (normalized.sleepHours ?? 0) >= 8) summaryBits.push('Good sleep');
      if (normalized.sleep_low) summaryBits.push('Poor sleep');
      if (normalized.onset) summaryBits.push('Late sleep');
      if (normalized.night) summaryBits.push('Night waking');
      if (normalized.prn_sleep) summaryBits.push('PRN sleep');
      if (normalized.prn_mania) summaryBits.push('PRN mania');
      if (normalized.prn_aggr) summaryBits.push('PRN aggression');
      if (normalized.tired) summaryBits.push('Appears tired');
      if (normalized.manic) summaryBits.push('Manic');
      if (normalized.sick) summaryBits.push('Sick');
      if (normalized.temp) summaryBits.push('Temp');
      if (normalized.med_change) summaryBits.push('Med change');
      if (normalized.appetite) summaryBits.push('Appetite');
      if (normalized.moon) summaryBits.push('Full moon');
      if (normalized.anomaly) summaryBits.push('Anomaly');
      const eventBody = {
        title: summaryBits.length ? `Health: ${summaryBits.join(', ')}` : 'Health update',
        type: 'health-flag',
        start_date: dateKey,
        start_time: null,
        end_time: null,
        all_day: true,
        notes: JSON.stringify(normalized),
        location: null,
        group_id: groupId,
        created_by: CURRENT_USER_ID
      };
      const existing = HEALTH_FLAGS[dateKey];
    try {
      let savedRow = null;
      if (existing?.id) {
        const resp = await rest(`calendar_events?id=eq.${encodeURIComponent(existing.id)}`, {
          method:'PATCH',
          headers:{ Prefer:'return=representation' },
          body: JSON.stringify(eventBody)
        });
        savedRow = Array.isArray(resp) ? resp[0] : resp;
      } else {
        const rows = await rest('calendar_events', {
          method:'POST',
          headers:{ Prefer:'return=representation' },
          body: JSON.stringify([eventBody])
        });
        savedRow = Array.isArray(rows) ? rows[0] : rows;
      }
      if (LOCAL_HEALTH[dateKey]) {
        delete LOCAL_HEALTH[dateKey];
        saveLocalHealth();
      }
      const id = savedRow?.id || existing?.id || null;
      HEALTH_FLAGS[dateKey] = { id, data: normalized };
      applyHealthFlagToMap(dateKey, normalized);
      render();
      updateMonthlyShifts();
      stampHealthUpdate();
    } catch (error) {
      console.warn('health flag save failed (using local cache)', error?.message || error);
      LOCAL_HEALTH[dateKey] = normalized;
      saveLocalHealth();
      HEALTH_FLAGS[dateKey] = { id:null, data:normalized };
      applyHealthFlagToMap(dateKey, normalized);
      render();
      updateMonthlyShifts();
      stampHealthUpdate();
    }
  }

  const prevBtn = document.getElementById('hc-prev');
  prevBtn && prevBtn.addEventListener('click', () => { M--; if(M<0){ M=11; Y--; } loadMonth(); });
  const nextBtn = document.getElementById('hc-next');
  nextBtn && nextBtn.addEventListener('click', () => { M++; if(M>11){ M=0; Y++; } loadMonth(); });
  document.querySelectorAll('input[data-hc-layer]').forEach(cb=>{
    cb.addEventListener('change', () => { layers[cb.dataset.hcLayer] = cb.checked; render(); });
  });
  editorForm?.addEventListener('submit', async (event) => {
    event.preventDefault();
    if (!editorDateKey) return;
    await saveHealthFlagEntry(editorDateKey, {
      bm: editorForm.elements.bm?.checked,
      sleep: editorForm.elements.sleep?.checked,
      sleep_low: editorForm.elements.sleep_low?.checked,
      onset: editorForm.elements.onset?.checked,
      night: editorForm.elements.night?.checked,
      prn_sleep: editorForm.elements.prn_sleep?.checked,
      prn_mania: editorForm.elements.prn_mania?.checked,
      prn_aggr: editorForm.elements.prn_aggr?.checked,
      tired: editorForm.elements.tired?.checked,
      manic: editorForm.elements.manic?.checked,
      sick: editorForm.elements.sick?.checked,
      temp: editorForm.elements.temp?.checked,
      med_change: editorForm.elements.med_change?.checked,
      moon: editorForm.elements.moon?.checked,
      appetite: editorForm.elements.appetite?.checked,
      anomaly: editorForm.elements.anomaly?.checked,
      sleepHours: editorSleep.value,
      note: editorNotes.value
    });
    closeEditor();
  });
  editorCancelBtn?.addEventListener('click', closeEditor);
  editorOverlay?.addEventListener('click', (event) => {
    if (event.target === editorOverlay) closeEditor();
  });
  editorQuick?.addEventListener('change', () => {
    const value = editorQuick.value;
    if (!value) return;
    const input = editorForm?.elements[value];
    if (input) input.checked = true;
    if (value === 'sleep' && !editorSleep.value) editorSleep.value = '8';
    editorQuick.value = '';
  });

  // Boot
  (async () => {
    await loadMonth();
  })();
})();
</script>
